<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>Introduction au C - Deimos.fr / Bloc Notes Informatique</title>
<meta name="generator" content="MediaWiki 1.25.5" />
<link rel="shortcut icon" href="https://wiki.deimos.fr/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Deimos.fr / Bloc Notes Informatique (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.deimos.fr/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="Introduction_au_C.html" />
<link rel="copyright" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.fr" />
<link rel="alternate" type="application/atom+xml" title="Deimos.fr / Bloc Notes Informatique Atom feed" href="https://wiki.deimos.fr/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="load.php%3Fdebug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint,shared|mediawiki.sectionAnchor|mediawiki.skinning.interface|mediawiki.ui.button|skins.vector.styles&amp;only=styles&amp;skin=vector&amp;*.css" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="load.php%3Fdebug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*.css" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: blocnotesinfo-wiki_:resourceloader:filter:minify-css:7:6f8c0c45eefd74c7bbe9478b32df38c0 */</style>
<script src="load.php%3Fdebug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Introduction_au_C","wgTitle":"Introduction au C","wgCurRevisionId":9465,"wgRevisionId":9465,"wgArticleId":2906,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Introduction_au_C","wgRelevantArticleId":2906,"wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"publish":false}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: blocnotesinfo-wiki_:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Introduction_au_C skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Introduction au C</span></h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From Deimos.fr / Bloc Notes Informatique</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="Introduction_au_C.html#mw-navigation">navigation</a>, 					<a href="Introduction_au_C.html#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Introduction_au_C.html#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Introduction_au_C.html#Programmes_et_fonctions"><span class="tocnumber">2</span> <span class="toctext">Programmes et fonctions</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="Introduction_au_C.html#Premier_Programme"><span class="tocnumber">2.1</span> <span class="toctext">Premier Programme</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="Introduction_au_C.html#Commentaires"><span class="tocnumber">2.1.1</span> <span class="toctext">Commentaires</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-5"><a href="Introduction_au_C.html#Fonctions"><span class="tocnumber">2.2</span> <span class="toctext">Fonctions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="Introduction_au_C.html#Les_macros"><span class="tocnumber">3</span> <span class="toctext">Les macros</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="Introduction_au_C.html#Le_pr.C3.A9processeur"><span class="tocnumber">3.1</span> <span class="toctext">Le préprocesseur</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="Introduction_au_C.html#Variables_globales_multi_fichiers"><span class="tocnumber">3.2</span> <span class="toctext">Variables globales multi fichiers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="Introduction_au_C.html#Expressions_et_instructions"><span class="tocnumber">4</span> <span class="toctext">Expressions et instructions</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="Introduction_au_C.html#Les_types_de_donn.C3.A9es"><span class="tocnumber">4.1</span> <span class="toctext">Les types de données</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="Introduction_au_C.html#int"><span class="tocnumber">4.1.1</span> <span class="toctext">int</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="Introduction_au_C.html#Nombres_entiers"><span class="tocnumber">4.1.2</span> <span class="toctext">Nombres entiers</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="Introduction_au_C.html#Nombres_Flottants_.28floats.29"><span class="tocnumber">4.1.3</span> <span class="toctext">Nombres Flottants (floats)</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="Introduction_au_C.html#Type_char"><span class="tocnumber">4.1.4</span> <span class="toctext">Type char</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="Introduction_au_C.html#Sp.C3.A9cification_de_format_dans_sprintf"><span class="tocnumber">4.2</span> <span class="toctext">Spécification de format dans sprintf</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="Introduction_au_C.html#Les_variables_et_les_constantes"><span class="tocnumber">4.3</span> <span class="toctext">Les variables et les constantes</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="Introduction_au_C.html#Les_constantes"><span class="tocnumber">4.3.1</span> <span class="toctext">Les constantes</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="Introduction_au_C.html#Les_variables"><span class="tocnumber">4.3.2</span> <span class="toctext">Les variables</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-19"><a href="Introduction_au_C.html#D.C3.A9finition_de_nouveaux_types"><span class="tocnumber">4.4</span> <span class="toctext">Définition de nouveaux types</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="Introduction_au_C.html#Les_pointeurs"><span class="tocnumber">4.5</span> <span class="toctext">Les pointeurs</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21"><a href="Introduction_au_C.html#Entr.C3.A9es_et_sorties"><span class="tocnumber">5</span> <span class="toctext">Entrées et sorties</span></a>
<ul>
<li class="toclevel-2 tocsection-22"><a href="Introduction_au_C.html#Saisir_des_donn.C3.A9es_tap.C3.A9es_au_clavier_avec_la_fonction_scanf"><span class="tocnumber">5.1</span> <span class="toctext">Saisir des données tapées au clavier avec la fonction scanf</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="Introduction_au_C.html#Exemple_de_permutation_des_contenus_de_deux_variables"><span class="tocnumber">5.2</span> <span class="toctext">Exemple de permutation des contenus de deux variables</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="Introduction_au_C.html#Op.C3.A9rateurs_arithm.C3.A9tiques_courants"><span class="tocnumber">5.3</span> <span class="toctext">Opérateurs arithmétiques courants</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="Introduction_au_C.html#Op.C3.A9rateurs_de_comparaison"><span class="tocnumber">5.4</span> <span class="toctext">Opérateurs de comparaison</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="Introduction_au_C.html#Op.C3.A9rateurs_logiques"><span class="tocnumber">5.5</span> <span class="toctext">Opérateurs logiques</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="Introduction_au_C.html#Sizeof_:_Taille_des_donn.C3.A9es"><span class="tocnumber">5.6</span> <span class="toctext">Sizeof&#160;: Taille des données</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="Introduction_au_C.html#Les_op.C3.A9rateurs_d.27incr.C3.A9mentation_et_de_d.C3.A9cr.C3.A9mentation"><span class="tocnumber">5.7</span> <span class="toctext">Les opérateurs d'incrémentation et de décrémentation</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="Introduction_au_C.html#Expression_conditionnelle"><span class="tocnumber">5.8</span> <span class="toctext">Expression conditionnelle</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-30"><a href="Introduction_au_C.html#Les_caract.C3.A8res"><span class="tocnumber">6</span> <span class="toctext">Les caractères</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="Introduction_au_C.html#Conversions"><span class="tocnumber">6.1</span> <span class="toctext">Conversions</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="Introduction_au_C.html#Implicites"><span class="tocnumber">6.1.1</span> <span class="toctext">Implicites</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="Introduction_au_C.html#Explicites_.28cast.29"><span class="tocnumber">6.1.2</span> <span class="toctext">Explicites (cast)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-34"><a href="Introduction_au_C.html#Les_instructions"><span class="tocnumber">7</span> <span class="toctext">Les instructions</span></a>
<ul>
<li class="toclevel-2 tocsection-35"><a href="Introduction_au_C.html#if"><span class="tocnumber">7.1</span> <span class="toctext">if</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="Introduction_au_C.html#do"><span class="tocnumber">7.2</span> <span class="toctext">do</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="Introduction_au_C.html#while"><span class="tocnumber">7.3</span> <span class="toctext">while</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="Introduction_au_C.html#for"><span class="tocnumber">7.4</span> <span class="toctext">for</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="Introduction_au_C.html#break"><span class="tocnumber">7.5</span> <span class="toctext">break</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="Introduction_au_C.html#Switch_et_case"><span class="tocnumber">7.6</span> <span class="toctext">Switch et case</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="Introduction_au_C.html#Continue"><span class="tocnumber">7.7</span> <span class="toctext">Continue</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="Introduction_au_C.html#Return"><span class="tocnumber">7.8</span> <span class="toctext">Return</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-43"><a href="Introduction_au_C.html#Tableaux.2C_pointeurs_et_cha.C3.AEnes_de_caract.C3.A8res"><span class="tocnumber">8</span> <span class="toctext">Tableaux, pointeurs et chaînes de caractères</span></a>
<ul>
<li class="toclevel-2 tocsection-44"><a href="Introduction_au_C.html#Initialisation"><span class="tocnumber">8.1</span> <span class="toctext">Initialisation</span></a>
<ul>
<li class="toclevel-3 tocsection-45"><a href="Introduction_au_C.html#Calculer_la_taille_d.27un_tableau"><span class="tocnumber">8.1.1</span> <span class="toctext">Calculer la taille d'un tableau</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-46"><a href="Introduction_au_C.html#Multidimentions"><span class="tocnumber">8.2</span> <span class="toctext">Multidimentions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="Introduction_au_C.html#Arithm.C3.A9tique_des_pointeurs"><span class="tocnumber">9</span> <span class="toctext">Arithmétique des pointeurs</span></a>
<ul>
<li class="toclevel-2 tocsection-48"><a href="Introduction_au_C.html#Introduction_au_calcul_d.27adresses"><span class="tocnumber">9.1</span> <span class="toctext">Introduction au calcul d'adresses</span></a></li>
<li class="toclevel-2 tocsection-49"><a href="Introduction_au_C.html#L.27arithm.C3.A9tique_des_pointeurs"><span class="tocnumber">9.2</span> <span class="toctext">L'arithmétique des pointeurs</span></a></li>
<li class="toclevel-2 tocsection-50"><a href="Introduction_au_C.html#Pointeurs_g.C3.A9n.C3.A9riques"><span class="tocnumber">9.3</span> <span class="toctext">Pointeurs génériques</span></a></li>
<li class="toclevel-2 tocsection-51"><a href="Introduction_au_C.html#Exemple_avec_un_tableau_.C3.A0_plusieurs_dimensions"><span class="tocnumber">9.4</span> <span class="toctext">Exemple avec un tableau à plusieurs dimensions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-52"><a href="Introduction_au_C.html#Les_cha.C3.AEnes_de_caract.C3.A8res"><span class="tocnumber">10</span> <span class="toctext">Les chaînes de caractères</span></a>
<ul>
<li class="toclevel-2 tocsection-53"><a href="Introduction_au_C.html#Repr.C3.A9sentation_des_cha.C3.AEnes_de_caract.C3.A8res_en_langage_C"><span class="tocnumber">10.1</span> <span class="toctext">Représentation des chaînes de caractères en langage C</span></a></li>
<li class="toclevel-2 tocsection-54"><a href="Introduction_au_C.html#strcpy.2C_strncpy"><span class="tocnumber">10.2</span> <span class="toctext">strcpy, strncpy</span></a></li>
<li class="toclevel-2 tocsection-55"><a href="Introduction_au_C.html#strcat.2C_strncat"><span class="tocnumber">10.3</span> <span class="toctext">strcat, strncat</span></a></li>
<li class="toclevel-2 tocsection-56"><a href="Introduction_au_C.html#strlen"><span class="tocnumber">10.4</span> <span class="toctext">strlen</span></a></li>
<li class="toclevel-2 tocsection-57"><a href="Introduction_au_C.html#strcmp.2C_strncmp"><span class="tocnumber">10.5</span> <span class="toctext">strcmp, strncmp</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="Introduction_au_C.html#Impl.C3.A9mentation_de_quelques_fonctions_de_manipulation_de_cha.C3.AEne"><span class="tocnumber">10.6</span> <span class="toctext">Implémentation de quelques fonctions de manipulation de chaîne</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="Introduction_au_C.html#lire_un_caract.C3.A8re.2C_puis_l.27afficher"><span class="tocnumber">10.7</span> <span class="toctext">lire un caractère, puis l'afficher</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="Introduction_au_C.html#Saisir_une_cha.C3.AEne_de_caract.C3.A8res"><span class="tocnumber">10.8</span> <span class="toctext">Saisir une chaîne de caractères</span></a></li>
<li class="toclevel-2 tocsection-61"><a href="Introduction_au_C.html#Lire_une_ligne_avec_fgets"><span class="tocnumber">10.9</span> <span class="toctext">Lire une ligne avec fgets</span></a></li>
<li class="toclevel-2 tocsection-62"><a href="Introduction_au_C.html#M.C3.A9canisme_des_entr.C3.A9es.2Fsorties_en_langage_C"><span class="tocnumber">10.10</span> <span class="toctext">Mécanisme des entrées/sorties en langage C</span></a>
<ul>
<li class="toclevel-3 tocsection-63"><a href="Introduction_au_C.html#Lire_de_mani.C3.A8re_s.C3.BBre_des_donn.C3.A9es_sur_l.27entr.C3.A9e_standard"><span class="tocnumber">10.10.1</span> <span class="toctext">Lire de manière sûre des données sur l'entrée standard</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-64"><a href="Introduction_au_C.html#L.27allocation_dynamique_de_m.C3.A9moire"><span class="tocnumber">11</span> <span class="toctext">L'allocation dynamique de mémoire</span></a></li>
<li class="toclevel-1 tocsection-65"><a href="Introduction_au_C.html#Ressources"><span class="tocnumber">12</span> <span class="toctext">Ressources</span></a></li>
</ul>
</div>

<h1><span class="mw-headline" id="Introduction"><span class="mw-headline-number">1</span> Introduction</span></h1>
<p>L'Histoire du langage C est intimement liée à celle du système d'exploitation UNIX. En 1965, Ken Thompson, de Bell Labs, développait un système d'exploitation qu'il baptisa MULTICS (Multiplexed Information and Computing System) afin de faire tourner un jeu qu'il avait créé, et qui donna naissance en 1970 au système d'exploitation UNICS (Uniplexed Information and Computing System) rapidement rebaptisé UNIX.
</p><p>A l'époque, le seul langage qui permettait de développer un système d'exploitation était le langage d'assemblage. Ken Thompson développa alors un langage de plus haut niveau, le langage B (dont le nom provient de BCPL, un sous-ensemble du langage CPL, lui-même dérivé de l'Algol, un langage qui fut populaire à l'époque), pour faciliter l'écriture des systèmes d'exploitations. C'était un langage faiblement typé (un langage non typé, par opposition à un langage typé, est un langage qui manipule les objets sous leur forme binaire, sans notion de type (caractère, entier, réel, ...)) et trop dépendant du PDP-7 (la machine sur laquelle a été développé UNIX) pour permettre de porter UNIX sur d'autres machines. Alors Denis Ritchie (qui fut, avec Ken Thompson, l'un des créateurs d'UNIX) et Brian Kernighan améliorèrent le langage B pour donner naissance au langage C. En 1973, UNIX fut réécrit entièrement en langage C. Pendant 5 ans, le langage C fut limité à l'usage interne de Bell jusqu'au jour ou Brian Kernighan et Denis Ritchie publièrent une première définition du langage dans un ouvrage intitulé The C Programming Language. Ce fut le début d'une révolution dans le monde de l'informatique.
</p><p>Grâce à sa puissance, le langage C devint rapidement très populaire et en 1983, l'ANSI (American National Standards Institute) décida de le normaliser en ajoutant également quelques modifications et améliorations, ce qui donna naissance en 1989 au langage tel que nous le connaissons aujourd'hui.
</p><p>Les caractéristiques du langage C sont les suivants&#160;:
</p>
<ul><li> Universalité&#160;: langage de programmation par excellence, le C n'est pas confiné à un domaine particulier d'applications. Il peut être utilisé aussi bien pour l'écriture de systèmes d'exploitations que de programmes scientifiques ou de gestion, de logiciels modernes, de bases de données, de compilateurs, assembleurs ou intérpréteurs, ...</li>
<li> Souplesse&#160;: c'est un langage concis, très expressif, et les programmes écrits dans ce langage sont très compacts grâce à un jeu d'opérateurs puissant. Votre seule limite est votre imagination&#160;!</li>
<li> Puissance&#160;: le C est un langage de haut niveau mais qui permet d'effectuer des opérations de bas niveau et d'accéder aux fonctionnalités du système, ce qui est la plupart du temps impossible dans les autres langages de haut niveau.</li>
<li> Portabilité&#160;: c'est un langage qui ne dépend d'aucune plateforme matérielle ou logicielle. Le C permet en outre d'écrire des programmes portables, c'est-à-dire qui pourront être compilés pour n'importe quelle plateforme sans aucune modification.</li></ul>
<p>De plus, sa popularité mais surtout l'élégance des programmes écrits en C est telle que sa syntaxe a influencé de nombreux langages dont C++ (qui est considéré comme un sur ensemble du C), JavaScript, Java, PHP et C#.
</p>
<h1><span class="mw-headline" id="Programmes_et_fonctions"><span class="mw-headline-number">2</span> Programmes et fonctions</span></h1>
<h2><span class="mw-headline" id="Premier_Programme"><span class="mw-headline-number">2.1</span> Premier Programme</span></h2>
<p>Nous allons écrire un simple programme "Hello World"&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Hello, world<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p><b>main</b> est la fonction principale du code que vous allez écrire. C'est par elle que tout va commencer quand vous allez appeler votre programme.
</p><p>Selon la norme officielle du langage C, main est une fonction qui <b>doit retourner un entier (int)</b>. Chez de nombreux systèmes (dont Windows et UNIX), cet entier est appelé le code d'erreur de l'application. En langage C, bien que cela ne soit pas forcément le cas pour le système d'exploitation, on retourne 0 pour dire que tout s'est bien passé.
</p><p>Comme dans beaucoup de languages, il nous faut déclarer chaque variable que nous allons utiliser. Ici c'est simple, c'est le chargement préprocesseur stdio.h qui s'en occupera à notre place.
</p><p>Ensuite, nous allons le compiler pour voir les éventuelles erreurs et pour pouvoir lancer notre premier programme&#160;:-)&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> gcc</font>
</td></tr>
<tr>
<td>
<pre>gcc -Wall hello_world.c -o hello_world
</pre>
</td></tr></table><br />
<ul><li> gcc&#160;: la commande qui correspond au compilateur utilisé.</li>
<li> -Wall&#160;: activation du mode warning pour les éventuelles erreurs. Très pratique pour débugger</li>
<li> hello_world.c&#160;: fichier source</li>
<li> hello_world&#160;: binaire de destination</li></ul>
<h3><span class="mw-headline" id="Commentaires"><span class="mw-headline-number">2.1.1</span> Commentaires</span></h3>
<p>Pour ce qui est des commentaires, voici les solutions&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">// Commentaire à la façon C++ mais qui devrait fonctionner avec tous les compilos récents</span></pre></div></div>
<p>ou
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="coMULTI">/* On peut commencer un paragraphe
de commentaire sans ce soucier
de quoi que ce soit jusqu'à la fin */</span></pre></div></div>
<h2><span class="mw-headline" id="Fonctions"><span class="mw-headline-number">2.2</span> Fonctions</span></h2>
<p>En mathématiques, on définit une fonction comme suit&#160;:
</p>
<pre>f(x) = x2 - 3
</pre>
<p>Cela signifie que f est une fonction qui reçoit en argument un réel x et qui retourne un réel&#160;: x2 - 3.
</p><p>Ecrivons une fonction C que nous appellerons f, qui reçoit en argument un entier x et qui retourne également un entier&#160;: x2 - 3&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> f<span class="br0">&#40;</span><span class="kw4">int</span> x<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> x<span class="sy0">*</span>x <span class="sy0">-</span> <span class="nu0">3</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Maintenant, utilisons cette fonction&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> f<span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="coMULTI">/* declaration de la fonction f */</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;f(%d) =&#160;%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> x<span class="sy0">,</span> f<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw4">int</span> f<span class="br0">&#40;</span><span class="kw4">int</span> x<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> x<span class="sy0">*</span>x <span class="sy0">-</span> <span class="nu0">3</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>int f(int x) dit&#160;: f est une fonction qui nécessite en argument un int et qui retourne un int.<br />
Le&#160;%d dans la fonction printf est ce qu'on appelle un spécificateur de format. Elle renseigne sur la manière dont nous souhaitons afficher le texte. Ici, on veut afficher les nombres 4 et 13 (f(4)). Nous disons donc à printf d'utiliser le format «&#160;nombre entier&#160;» (%d) pour les afficher. Le premier&#160;%d correspond au format que nous voulons utiliser pour afficher x et le deuxième pour f(x).
</p><p>Sachez également que la variable x dans la fonction main n'a absolument rien à voir avec la variable x en paramètre de la fonction f. Chaque fonction peut avoir ses propres variables et ignore complètement ce qui se passe chez les autres fonctions.
</p><p><i>Note</i>&#160;: Dans une déclaration, on peut mettre le nom des arguments de la fonction (bon uniquement pour la déco et rien d'autre)&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> Surface<span class="br0">&#40;</span><span class="kw4">int</span> Longueur<span class="sy0">,</span> <span class="kw4">int</span> largeur<span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>De même il est fortement conseillé de déclarer quel type d'argument de fonction vous allez utiliser. Utilisez plutôt&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> Surface<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="coMULTI">/* void&#160;: 'vide', ou 'rien' si vous préférez */</span></pre></div></div>
<p>à la place de ne rien mettre comme&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> Surface<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="coMULTI">/* Surface est une fonction. Point. */</span></pre></div></div>
<p>Dans une définition (implémentation)&#160;:
</p>
<ul><li> On peut ne pas préciser le type de retour d'une fonction. Dans ce cas celle-ci est supposée retourner un int.</li>
<li> Une paire de parenthèses vide signifie que la fonction n'accepte aucun argument.</li></ul>
<p>Autres remarques&#160;:
</p>
<ul><li> La déclaration d'une fonction n'est nécessaire que lorsque son utilisation précède sa définition. Cependant, il est toujours conseillé de ne définir une fonction qu'après son utilisation (ce qui requiert donc une déclaration) ne serait-ce que pour la lisibilité du programme (en effet c'est le programme qu'on veut voir à première vue, pas les petits détails).</li>
<li> Une fonction peut ne pas retourner de valeur. Son type de retour est alors void.</li></ul>
<h1><span class="mw-headline" id="Les_macros"><span class="mw-headline-number">3</span> Les macros</span></h1>
<h2><span class="mw-headline" id="Le_pr.C3.A9processeur"><span class="mw-headline-number">3.1</span> Le préprocesseur</span></h2>
<p>Avant d'être effectivement compilés, les fichiers sources C sont traités par un préprocesseur qui résout certaines directives qui lui sont données comme l'inclusion de fichier par exemple. Le préprocesseur, quoi qu'étant un programme à priori indépendant du compilateur, est un élément indispensable du langage.
</p><p>Une directive donnée au préprocesseur commence toujours par #. Nous avons déjà rencontré la directive include qui permet d'inclure un fichier. La directive define permet de définir des macros. 
</p><p>Une macro, dans sa forme la plus simple, se définit de la manière suivante&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define &lt;macro&gt; &lt;le texte de remplacement&gt;</span></pre></div></div>
<p>Pour remplacer par exemple toutes les occurences PLUS par +&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define PLUS +</span></pre></div></div>
<p>De même, cela peut même remplacer parfois des fonctions&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define carre(x) x * x</span></pre></div></div>
<p>Dans ce cas, carre(3) sera remplacer par 3 * 3. Et pour terminer&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define PI 3.14</span></pre></div></div>
<p>Le compilateur remplace ici chaque occurrence de PI par 3.14. On peut également faire une constante symbolique&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define USER &quot; Toto &quot;</span></pre></div></div>
<h2><span class="mw-headline" id="Variables_globales_multi_fichiers"><span class="mw-headline-number">3.2</span> Variables globales multi fichiers</span></h2>
<p>Par défaut, une variable globale n’est accessible que dans le fichier source dans lequel elle est déclarée, car chaque fichier source va être compilé dans un fichier objet indépendant. Cependant, il est possible de rendre une variable globale accessible dans tous les fichiers source d’un programme grâce au mot clé extern. Cette pratique, est toutefois à éviter&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw2">extern</span> my_extern_var</pre></div></div>
<h1><span class="mw-headline" id="Expressions_et_instructions"><span class="mw-headline-number">4</span> Expressions et instructions</span></h1>
<h2><span class="mw-headline" id="Les_types_de_donn.C3.A9es"><span class="mw-headline-number">4.1</span> Les types de données</span></h2>
<table border="1">
<tr>
<th>Type C
</th>
<th>Type correspondant
</th></tr>
<tr>
<td>char
</td>
<td>caractère (entier de petite taille)
</td></tr>
<tr>
<td>int
</td>
<td>entier
</td></tr>
<tr>
<td>float
</td>
<td>nombre flottant (réel) en simple précision
</td></tr>
<tr>
<td>double
</td>
<td>nombre flottant (réel) en double précision
</td></tr></table>
<p>Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> ch<span class="sy0">;</span>
<span class="kw4">unsigned</span> <span class="kw4">char</span> c<span class="sy0">;</span>
<span class="kw4">unsigned</span> <span class="kw4">int</span> n<span class="sy0">;</span> <span class="coMULTI">/* ou tout simplement&#160;: unsigned n */</span></pre></div></div>
<p><b>La plus petite valeur possible que l'on puisse affecter à une variable de type entier non signé est 0 alors que les entiers signés acceptent les valeurs négatives.</b>
</p>
<h3><span class="mw-headline" id="int"><span class="mw-headline-number">4.1.1</span> int</span></h3>
<p>Devant int, on peut mettre également short ou long auxquels cas on obtiendrait un entier court (short int ou tout simplement short) respectivement un entier long (long int ou tout simplement long). Voici des exemples de déclarations valides&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">,</span> m <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
<span class="kw4">short</span> a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="sy0">;</span>
<span class="kw4">long</span> x<span class="sy0">,</span> y<span class="sy0">,</span> z <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="kw4">unsigned</span> <span class="kw4">long</span> p <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span></pre></div></div>
<p>long peut être également mis devant double, le type résultant est alors long double (quadruple précision).
</p><p><br />
Devant char ou int, on peut mettre le modificateur <b>signed ou unsigned</b> selon que l'on veut avoir un entier signé (par défaut) ou non signé. signed int est la valeur signée (négative ou positive). unsigned int représente des valeurs positive.
</p>
<table border="1">
<tr>
<th>Nom de type
</th>
<th>Autre Nom
</th>
<th>Intervalle de valeur
</th>
<th>Octets
</th></tr>
<tr>
<td>int
</td>
<td>signed, unsigned int
</td>
<td>-32 768 à 32 767
</td>
<td>2
</td></tr>
<tr>
<td>short
</td>
<td>short_int, signed short, signed short_int
</td>
<td>-32 768 à 32 767
</td>
<td>2
</td></tr>
<tr>
<td>long
</td>
<td>long_int, signed long, signed long_int
</td>
<td>-2 147 493 648 à 2 147 483 647
</td>
<td>4
</td></tr>
<tr>
<td>unsigned
</td>
<td>unsigned int
</td>
<td>0 à 65 535
</td>
<td>2
</td></tr>
<tr>
<td>unsigned short
</td>
<td>unsigned short_int
</td>
<td>0 à 65 535
</td>
<td>2
</td></tr>
<tr>
<td>unsigned long
</td>
<td>unsigned long_int
</td>
<td>0 à 4 294 967 295
</td>
<td>4
</td></tr></table>
<h3><span class="mw-headline" id="Nombres_entiers"><span class="mw-headline-number">4.1.2</span> Nombres entiers</span></h3>
<ul><li> Toute constante littérale «&#160;pure&#160;» de type entier (ex&#160;: 1, -3, 60, 40, -20, ...) est considérée par le langage comme étant de type int.</li>
<li> Pour expliciter qu'une constante littérale de type entier est de type unsigned, il suffit d'ajouter à la constante le suffixe u ou U. Par exemple&#160;: 2u, 30u, 40U, 50U, ...</li>
<li> De même, il suffit d'ajouter le suffixe l ou L pour expliciter qu'une constante littérale de type entier est de type long (on pourra utiliser le suffixe UL par exemple pour unsigned long).</li>
<li> Une constante littérale de type entier peut également s'écrire en octal (base 8) ou en hexadécimal (base 16). L'écriture en hexa est évidement beaucoup plus utilisée.</li>
<li> Une constante littérale écrite en octal doit être précédée de 0 (zéro). Par exemple&#160;: 012, 020, 030UL, etc.</li>
<li> Une constante littérale écrite en hexadécimal doit commencer par 0x (zéro x). Par exemple 0x30, 0x41, 0x61, 0xFFL, etc. </li></ul>
<h3><span class="mw-headline" id="Nombres_Flottants_.28floats.29"><span class="mw-headline-number">4.1.3</span> Nombres Flottants (floats)</span></h3>
<p>Il désigne les nombres décimaux réels (positifs ou négatifs) (à virgule flottante). Toute constante littérale «&#160;pure&#160;» de type flottant (ex&#160;: 0.5, -1.2, ...) est considérée comme étant de <b>type double</b>.
</p><p>Le suffixe <b>f ou F permet d'expliciter un float</b>. Attention, 1f n'est pas valide car 1 est une constante entière. Par contre <b>1.0f est tout à fait correcte</b>. Le suffixe l ou L permet d'expliciter un long double.
</p><p>Une constante littérale de type flottant est constituée, dans cet ordre&#160;:
</p>
<ul><li> d'un signe (+ ou -)</li>
<li> d'une suite de chiffres décimaux&#160;: la partie entière</li>
<li> d'un point&#160;: le séparateur décimal</li>
<li> d'une suite de chiffres décimaux&#160;: la partie décimale</li>
<li> d'une des deux lettres e ou E&#160;: symbole de la puissance de 10 (notation scientifique)</li>
<li> d'un signe (+ ou -)</li>
<li> d'une suite de chiffres décimaux&#160;: la puissance de 10</li></ul>
<p>Par exemple, les constantes littérales suivantes représentent bien des nombres flottants&#160;: 1.0, -1.1f, 1.6E-19, 6.02e23L, 0.5 3e8
</p>
<table border="1">
<tr>
<th>Nom de type
</th>
<th>Autre Nom
</th>
<th>Intervalle
</th></tr>
<tr>
<td>Floats
</td>
<td>-
</td>
<td>-3.4E38 à +3.4E38
</td></tr>
<tr>
<td>double
</td>
<td>
</td>
<td>-1.7E308 à +1.7E308
</td></tr>
<tr>
<td>long double
</td>
<td>
</td>
<td>-1.7E308 à +1.7E308
</td></tr></table>
<h3><span class="mw-headline" id="Type_char"><span class="mw-headline-number">4.1.4</span> Type char</span></h3>
<p>char est utilisé pour désigner des caractères&#160;:
</p>
<table border="1">
<tr>
<th>Nom de type
</th>
<th>Autre Nom
</th>
<th>Intervalle
</th>
<th>Octets
</th></tr>
<tr>
<td>char
</td>
<td>signed char
</td>
<td>-128 à 127
</td>
<td>1
</td></tr>
<tr>
<td>unsigned char
</td>
<td>
</td>
<td>-0 à 255
</td>
<td>1
</td></tr></table>
<ul><li> Les types de données de base ne contiennent qu’une seule valeur.</li>
<li> Les types dérivés ou agrégats peuvent contenir plus d’une valeur.
<ul><li>Exemple: chaînes, tableaux, structures, énumérations, unions, pointeurs.</li></ul></li></ul>
<h2><span class="mw-headline" id="Sp.C3.A9cification_de_format_dans_sprintf"><span class="mw-headline-number">4.2</span> Spécification de format dans sprintf</span></h2>
<p>Voici la liste des codes format que nous utiliserons les plus souvent par la suite&#160;:
</p>
<table border="1">
<tr>
<th>Code format
</th>
<th>Utilisation
</th></tr>
<tr>
<td>c
</td>
<td>Afficher un caractère
</td></tr>
<tr>
<td>d
</td>
<td>Afficher un int
</td></tr>
<tr>
<td>u
</td>
<td>Afficher un unsigned int
</td></tr>
<tr>
<td>x, X
</td>
<td>Afficher un entier dans le format hexadécimal
</td></tr>
<tr>
<td>f
</td>
<td>Afficher un float ou un double en notation décimale
</td></tr>
<tr>
<td>e
</td>
<td>Afficher un float ou un double en notation scientifique avec un petit e
</td></tr>
<tr>
<td>E
</td>
<td>Afficher un float ou un double en notation scientifique avec un grand E
</td></tr>
<tr>
<td>g, G
</td>
<td>Afficher un float ou un double (utilise le format le plus adapté)
</td></tr>
<tr>
<td>%
</td>
<td>Afficher le caractère '%'
</td></tr></table>
<p>De plus&#160;:
</p>
<ul><li> h devant d ou u indique que l'argument est un short</li>
<li> l devant d, u, x ou X indique que l'argument est de type long</li>
<li> L devant f, e, E ou g indique que l'argument est de type long double</li></ul>
<p>Il y a bien plus de possibilités (qu'il faut connaître&#160;!) que je ne détaillerais pas ici (mais nous utiliserons certaines d'entre elles le moment venu). N'hésitez donc surtout pas à consulter la doc.
</p>
<h2><span class="mw-headline" id="Les_variables_et_les_constantes"><span class="mw-headline-number">4.3</span> Les variables et les constantes</span></h2>
<h3><span class="mw-headline" id="Les_constantes"><span class="mw-headline-number">4.3.1</span> Les constantes</span></h3>
<p>En C il existe 4 types de base:
</p>
<ul><li> Les constantes entières.</li>
<li> Les constantes en virgule flottante (constante réelle).</li>
<li> Les constantes caractères.</li>
<li> Les constantes chaînes de caractère.</li></ul>
<p>Les 2 premières constantes sont des constantes numériques.
</p>
<ul><li> Les valeurs numériques entières sont&#160;: décimal, octal et hexadécimal.</li>
<li> En base 10&#160;: un point décimal, un exposant (Note: la précision dépends des compilateurs (min&#160;: 6 chiffres, max&#160;: 18 chiffres))</li>
<li> Caractères unique entre apostrophes (128 caractères)&#160;:
<ul><li> Caractère&#160;: 0...9 A...Z a...z</li>
<li> Code ASCII&#160;: 48...57 65...90 97...122</li></ul></li>
<li> Suite de caractères entre guillemets.
<ul><li> Le compilateur place automatiquement le caractère nul '\0' en fin de chaîne (invisible). "bonjour" est en fait "bonjour\0" ce qui est utile dans les programmes pour marquer une fin de chaîne. 'A' est différent de "A" car 'A' est un caractère avec la valeur ASCII 48 alors que "A" est une chaîne ("A\0") sans valeur numérique. "A" occupe plus de place que 'A'.</li></ul></li></ul>
<p>Voici comment créer des variables&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="sy0">;</span>
<span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> j<span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="kw4">double</span> x<span class="sy0">,</span> y<span class="sy0">,</span> z <span class="sy0">=</span> <span class="nu16">0.5</span><span class="sy0">;</span></pre></div></div>
<p>Une déclaration avec initialisation donne&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span></pre></div></div>
<p>Alors que voici une déclaration, suivit d'une affectation&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n<span class="sy0">;</span>
n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span></pre></div></div>
<p>Une constante est une variable dont la particularité est d'être en lecture seule (la valeur d'une constante ne peut pas être modifiée)&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">const</span> <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span></pre></div></div>
<p><b>N'oubliez pas de déclarer toutes vos variables ou constantes sous peine d'erreurs.</b>
</p>
<h3><span class="mw-headline" id="Les_variables"><span class="mw-headline-number">4.3.2</span> Les variables</span></h3>
<p>Une variable est une valeur d'un type définit qui peut être modifiée&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> a<span class="sy0">;</span>
a <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span></pre></div></div>
<h2><span class="mw-headline" id="D.C3.A9finition_de_nouveaux_types"><span class="mw-headline-number">4.4</span> Définition de nouveaux types</span></h2>
<p>Le C dispose d'un mécanisme très puissant permettant au programmeur de créer de nouveaux types de données en utilisant le mot clé typedef&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">typedef</span> <span class="kw4">int</span> ENTIER<span class="sy0">;</span></pre></div></div>
<p>Définit le type ENTIER comme n'étant autre que le type int. Rien ne nous empêche donc désormais d'écrire&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">ENTIER a<span class="sy0">,</span> b<span class="sy0">;</span></pre></div></div>
<p>Bien que dans ce cas, un simple #define aurait pu suffire, il est toujours recommandé d'utiliser typedef qui est beaucoup plus sûr.
</p><p>Pour déclarer les fonctions sans les définir, on utilise les prototypes. Les structures peuvent être déclarées de la manière suivante&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">class myclass<span class="sy0">;</span></pre></div></div>
<h2><span class="mw-headline" id="Les_pointeurs"><span class="mw-headline-number">4.5</span> Les pointeurs</span></h2>
<p>Comme nous le savons très bien, l'endroit où s'exécute un programme est la mémoire donc toutes les données du programme (les variables, les fonctions, ...) se trouvent en mémoire. Le langage C dispose d'un opérateur <b>&amp;</b> permettant de récupérer l'adresse en mémoire d'une variable ou d'une fonction quelconque. Par exemple, si n est une variable, <b>&amp;n désigne l'adresse de n</b>.
</p><p>Le C dispose également d'un opérateur <b>*</b> permettant d'accéder au contenu de la mémoire  dont l'adresse est donnée. Par exemple, supposons qu'on ait&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n<span class="sy0">;</span></pre></div></div>
<p>Alors les instructions suivantes sont strictement identiques&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span></pre></div></div>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="sy0">*</span><span class="br0">&#40;</span> <span class="sy0">&amp;</span>n <span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span></pre></div></div>
<p>Un pointeur (ou une variable de type pointeur) est une variable destinée à recevoir une adresse. On dit alors qu'elle pointe sur un emplacement mémoire. L'accès au contenu de la mémoire se fait par l'intermédiaire de l'opérateur *.
</p><p>Voici comment déclarer une variable p destinée à recevoir l'adresse d'une variable de type int&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> <span class="sy0">*</span>p<span class="sy0">;</span>
<span class="kw4">int</span> <span class="sy0">*</span> o<span class="sy0">;</span></pre></div></div>
<p>J'en ai mis une autre avec o, juste pour montrer qu'en C on peut mettre autant d'espaces que l'on veut. Et maintenant, voici d'autres exemples&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> <span class="sy0">*</span> p1<span class="sy0">,</span> p2<span class="sy0">,</span> p3<span class="sy0">;</span> <span class="coMULTI">/* Seul p1 est de type int *. Les autres sont simplement des int.*/</span>
<span class="kw4">int</span> <span class="sy0">*</span>p1<span class="sy0">,</span> <span class="sy0">*</span>p2<span class="sy0">,</span> <span class="sy0">*</span>p3<span class="sy0">;</span> <span class="coMULTI">/* Là évidement, ils sont tous des int*/</span>
<span class="coMULTI">/*Utilisation simplifiée avec un typedef&#160;:*/</span>
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="sy0">*</span> PINT<span class="sy0">;</span>
PINT p1<span class="sy0">,</span> p2<span class="sy0">,</span> p3<span class="sy0">;</span></pre></div></div>
<p>Par contre cela n'aurait pas marché si on avait défini PINT à l'aide d'un #define car cela nous amènerait au premier exemple.
</p>
<h1><span class="mw-headline" id="Entr.C3.A9es_et_sorties"><span class="mw-headline-number">5</span> Entrées et sorties</span></h1>
<h2><span class="mw-headline" id="Saisir_des_donn.C3.A9es_tap.C3.A9es_au_clavier_avec_la_fonction_scanf"><span class="mw-headline-number">5.1</span> Saisir des données tapées au clavier avec la fonction scanf</span></h2>
<p>Il faut bien comprendre 2 choses avant de commencer&#160;:
</p>
<ul><li> Si nous voulons afficher un entier (avec printf), nous devons afficher l'entier (la valeur de la variable).</li>
<li> Si nous voulons demander à l'utilisateur (celui qui utilise notre programme) de taper un nombre puis ranger le nombre ainsi tapé dans une variable, nous devons fournir l'adresse de la variable dans laquelle nous souhaitons ranger le nombre entré.</li></ul>
<p>Un exemple aidera la compréhension&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Ce programme calcule la somme de 2 nombres.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez la valeur de a&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%d&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>a<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez la valeur de b&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%d&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>b<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    c <span class="sy0">=</span> a <span class="sy0">+</span> b<span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;%d +&#160;%d =&#160;%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Attention aux espaces et ce que vous demandez de taper avec scanf. Par exemple, si vous souhaitez que la personne tapes 'ans' en + d'un nombre&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%d ans&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>a<span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>L'utilisateur qui tapera son age sera obligé de taper "x ans". Attention donc à ce qu'il faut taper avec scanf.
</p><p>C'est ce qu'on appelle une saisie formatée. Les fonctions telles que scanf sont plutôt destinées à être utilisées pour lire des données provenant d'un programme sûr (par l'intermédiaire d'un fichier par exemple), pas celles provenant d'un humain, qui sont sujettes à l'erreur. Les codes format utilisés dans scanf sont à peu près les mêmes que dans printf, sauf pour les flottants notamment. 
</p>
<table border="1">
<tr>
<th>Code format
</th>
<th>Utilisation
</th></tr>
<tr>
<td>f, e, g
</td>
<td>float
</td></tr>
<tr>
<td>lf, le, lg
</td>
<td>double
</td></tr>
<tr>
<td>Lf, Le, Lg
</td>
<td>long double
</td></tr></table>
<p>Voici un programme qui permet de calculer le volume d'un cône droit à base circulaire selon la formule&#160;: V = 1/3 * (B * h) où B est la surface de base soit pour une base circulaire&#160;: B = PI*R2, où R est le rayon de la base.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">double</span> Volume<span class="br0">&#40;</span><span class="kw4">double</span> r_base<span class="sy0">,</span> <span class="kw4">double</span> hauteur<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">double</span> R<span class="sy0">,</span> h<span class="sy0">,</span> V<span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Ce programme calcule le volume d'un cone.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez le rayon de la base&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%lf&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>R<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez la hauteur du cone&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%lf&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>h<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    V <span class="sy0">=</span> Volume<span class="br0">&#40;</span>R<span class="sy0">,</span> h<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Le volume du cone est&#160;:&#160;%f&quot;</span><span class="sy0">,</span> V<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw4">double</span> Volume<span class="br0">&#40;</span><span class="kw4">double</span> r_base<span class="sy0">,</span> <span class="kw4">double</span> hauteur<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#40;</span><span class="nu16">3.14</span> <span class="sy0">*</span> r_base <span class="sy0">*</span> r_base <span class="sy0">*</span> hauteur<span class="br0">&#41;</span> <span class="sy0">/</span> <span class="nu0">3</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h2><span class="mw-headline" id="Exemple_de_permutation_des_contenus_de_deux_variables"><span class="mw-headline-number">5.2</span> Exemple de permutation des contenus de deux variables</span></h2>
<p>Cette fonction doit donc pouvoir localiser les variables en mémoire autrement dit nous devons passer à cette fonction les adresses des variables dont on veut permuter le contenu&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">void</span> permuter<span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span> addr_a<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span> addr_b<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">,</span> b <span class="sy0">=</span> <span class="nu0">20</span><span class="sy0">;</span>
&#160;
    permuter<span class="br0">&#40;</span><span class="sy0">&amp;</span>a<span class="sy0">,</span> <span class="sy0">&amp;</span>b<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;a =&#160;%d<span class="es1">\n</span>b =&#160;%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> a<span class="sy0">,</span> b<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw4">void</span> permuter<span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span> addr_a <span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span> addr_b<span class="br0">&#41;</span>
<span class="coMULTI">/***************\
* addr_a &lt;-- &amp;a *
* addr_b &lt;-- &amp;b *
\***************/</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> c<span class="sy0">;</span>
&#160;
    c <span class="sy0">=</span> <span class="sy0">*</span>addr_a<span class="sy0">;</span>
    <span class="sy0">*</span>addr_a <span class="sy0">=</span> <span class="sy0">*</span>addr_b<span class="sy0">;</span>
    <span class="sy0">*</span>addr_b <span class="sy0">=</span> c<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h2><span class="mw-headline" id="Op.C3.A9rateurs_arithm.C3.A9tiques_courants"><span class="mw-headline-number">5.3</span> Opérateurs arithmétiques courants</span></h2>
<p>Les opérateurs arithmétiques courants +, -, * et / existent en langage C. Toutefois, la division entière est un tout petit peu délicate. En effet, si a et b sont des entiers, a / b vaut le quotient  de a et b c'est-à-dire par exemple, 29 / 5 vaut 5. Le reste d'une division entière s'obtient avec l'opérateur modulo&#160;%, c'est-à-dire, en reprenant l'exemple précédent, 29&#160;% 5 vaut 4.
</p>
<h2><span class="mw-headline" id="Op.C3.A9rateurs_de_comparaison"><span class="mw-headline-number">5.4</span> Opérateurs de comparaison</span></h2>
<table border="1">
<tr>
<th>Opérateur
</th>
<th>Rôle
</th></tr>
<tr>
<td>&lt;
</td>
<td>Inférieur à
</td></tr>
<tr>
<td>&gt;
</td>
<td>Supérieur à
</td></tr>
<tr>
<td>==
</td>
<td>Egal à
</td></tr>
<tr>
<td>&lt;=
</td>
<td>Inférieur ou égal à
</td></tr>
<tr>
<td>&gt;=
</td>
<td>Supérieur ou égal à
</td></tr>
<tr>
<td>!=
</td>
<td>Différent de
</td></tr></table>
<h2><span class="mw-headline" id="Op.C3.A9rateurs_logiques"><span class="mw-headline-number">5.5</span> Opérateurs logiques</span></h2>
<table border="1">
<tr>
<th>Opérateur
</th>
<th>Rôle
</th></tr>
<tr>
<td>&amp;&amp;
</td>
<td>ET
</td></tr>
<tr>
<td>||
</td>
<td>OU
</td></tr>
<tr>
<td>!
</td>
<td>NON
</td></tr></table>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> prop1<span class="sy0">,</span> prop2<span class="sy0">,</span> prop_ou<span class="sy0">,</span> prop_et<span class="sy0">,</span> prop_vrai<span class="sy0">;</span>
prop1 <span class="sy0">=</span> <span class="br0">&#40;</span><span class="nu0">1</span> <span class="sy0">&lt;</span> <span class="nu0">1000</span><span class="br0">&#41;</span><span class="sy0">;</span>
prop2 <span class="sy0">=</span> <span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">6</span><span class="br0">&#41;</span><span class="sy0">;</span>
prop_ou <span class="sy0">=</span> prop1 <span class="sy0">||</span> prop2<span class="sy0">;</span> <span class="coMULTI">/* VRAI, car prop1 est VRAI */</span>
prop_et <span class="sy0">=</span> prop1 <span class="sy0">&amp;&amp;</span> prop2<span class="sy0">;</span> <span class="coMULTI">/* FAUX, car prop2 est FAUX */</span>
prop_vrai <span class="sy0">=</span> prop1 <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>prop_2 <span class="coMULTI">/* VRAI car prop1 et&#160;!prop2 sont VRAI */</span></pre></div></div>
<h2><span class="mw-headline" id="Sizeof_:_Taille_des_donn.C3.A9es"><span class="mw-headline-number">5.6</span> Sizeof&#160;: Taille des données</span></h2>
<p>La taille d'une donnée désigne la taille, en octets, que celle-ci occupe en mémoire. Par extension de cette définition, la taille d'un type de données désigne la taille d'une donnée de ce type. Attention&#160;! octet désigne ici, par abus de langage, la taille d'un élément de mémoire sur la machine cible (la machine abstraite), c'est-à-dire la taille d'une case mémoire (qui vaut 8 bits dans la plupart des architectures actuelles), et non un groupe de 8 bits. En langage C, un octet (une case mémoire) est représenté par un char. La taille d'un char n'est donc pas forcément 8 bits, même si c'est le cas dans de nombreuses architectures, mais dépendante de la machine. La norme requiert toutefois qu'un char doit faire au moins 8 bits et que la macro CHAR_BIT, déclarée dans limits.h, indique la taille exacte d'un char sur la machine cible.
</p><p>Le C dispose d'un opérateur, sizeof, permettant de connaître la taille, en octets, d'une donnée ou d'un type de données. La taille d'un char vaut donc évidemment 1 puisqu'un char représente un octet. Par ailleurs, il ne peut y avoir de type dont la taille n'est pas multiple de celle d'un char. Le type de la valeur retournée par l'opérateur sizeof est size_t, déclaré dans stddef.h, qui est inclus par de nombreux fichiers d'en-tête dont stdio.h.
</p><p>Comme nous l'avons déjà dit plus haut, la taille des données est dépendante de la machine cible. En langage C, la taille des données n'est donc pas fixée. Néanmoins la norme stipule qu'on doit avoir&#160;: 
</p>
<pre>sizeof (char) &lt;= sizeof (short) &lt;= sizeof (int) &lt;= sizeofd(long)
</pre>
<p>Sur un processeur Intel (x86) 32 bits par exemple, un char fait 8 bits, un short 16 bits, et les int et les long 32 bits. 
</p>
<h2><span class="mw-headline" id="Les_op.C3.A9rateurs_d.27incr.C3.A9mentation_et_de_d.C3.A9cr.C3.A9mentation"><span class="mw-headline-number">5.7</span> Les opérateurs d'incrémentation et de décrémentation</span></h2>
<p>Tout comme dans beaucoups de languages&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">,</span> j<span class="sy0">;</span>
    j <span class="sy0">=</span> <span class="sy0">++</span>i<span class="sy0">;</span> <span class="coMULTI">/* j = 1+1 =&gt; j=2 */</span>
    <span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;j (++i) =&#160;%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> j<span class="br0">&#41;</span><span class="sy0">;</span> 
    j <span class="sy0">=</span> <span class="sy0">--</span>i<span class="sy0">;</span> <span class="coMULTI">/* j = 2-1 =&gt; j=1 */</span>
    <span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;j (--i) =&#160;%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> j<span class="br0">&#41;</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Que l'on note ++i ou i++ peut importe, l'effet est le même.
</p>
<h2><span class="mw-headline" id="Expression_conditionnelle"><span class="mw-headline-number">5.8</span> Expression conditionnelle</span></h2>
<p>Une expression conditionnelle est une expression dont la valeur dépend d'une condition. L'expression&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">p <span class="sy0">?</span> a <span class="sy0">:</span> b</pre></div></div>
<p>vaut a si p est vrai et b si p est faux. 
</p><p>Pour des opérations d'affectation, ce sont les opérateurs&#160;: +=, -=, *=, /=, ...
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">x <span class="sy0">+=</span> a<span class="sy0">;</span></pre></div></div>
<p>par exemple est équivalent à&#160;:
&lt;/syntaxhighlight&gt;
x = x + a;
&lt;/syntaxhighlight&gt;
Les opérateurs sont classés par ordre de priorité. Voici les opérateurs que nous avons étudiés jusqu'ici classés dans cet ordre. Opérateur Associativité
</p>
<table border="1">
<tr>
<th>Opérateur
</th>
<th>Associativité
</th></tr>
<tr>
<td>Parenthèses
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>! ++ -- - (signe) sizeof
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>* /&#160;%
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>+ -
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>&lt; &lt;= &gt; &gt;=
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>==&#160;!=
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>&amp; (adresse de)
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>&amp;&amp;
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>||
</td>
<td>de gauche à droite
</td></tr>
<tr>
<td>Opérateurs d'affectation (= += ...)
</td>
<td>de droite à gauche
</td></tr>
<tr>
<td>,
</td>
<td>de gauche à droite
</td></tr></table>
<p>Ce n'est pas parce que cet ordre existe qu'il faut le retenir par coeur. Pour du code lisible, il est même conseillé de ne pas trop en tenir compte et d'utiliser des parenthèses dans les situations ambiguës.
</p>
<h1><span class="mw-headline" id="Les_caract.C3.A8res"><span class="mw-headline-number">6</span> Les caractères</span></h1>
<p>La représentation numérique des caractères définit ce qu'on appelle un jeu de caractères. Par exemple, dans le jeu de caractères ASCII (American Standard Code for Information Interchange) qui est un jeu de caractères qui n'utilise que 7 bits et qui est à la base de nombreux codes populaires de nos jours, le caractère 'A' est représenté par le code 65, le caractère 'a' par 97 et '0' par 48. Hélas, même ASCII ne définit pas le langage C. En effet si le C dépendait d'un jeu de caractères particulier, il ne serait alors pas totalement portable. Le standard définit néanmoins un certain nombre de caractères que tout environnement compatible avec le C doit posséder parmi lesquels les 26 lettres de l'alphabet latin (donc en fait 52 puisqu'on différencie les majuscules et les minuscules), les 10 chiffres décimaux, les caractères # &lt; &gt; ( ) etc. Le programmeur (mais pas le compilateur) n'a pas besoin de connaître comment ces caractères sont représentés dans le jeu de caractères de l'environnement. Le standard ne définit donc pas un jeu de caractères mais seulement un ensemble de caractères que chaque environnement compatible est libre d'implémenter à sa façon (plus éventuellement les caractères spécifiques à cet environnement). La seule contrainte imposée est que leur valeur doit pouvoir tenir dans un char.
</p><p>Concernant la technique d'échappement, sachez également qu'on peut insérer du code octal (commençant par 0) ou hexadécimal (commençant par x) après le caractère d'échappement \ pour obtenir un caractère dont le code dans le jeu de caractères est donné. L'hexadécimal est de loin le plus utilisé. Par exemple&#160;: '\x30', '\x41', '\x61', ... Et enfin pour les caractères de code 0, 1, ... jusqu'à 7, on peut utiliser les raccourcis '\0', '\1', ... '\7'. 
</p><p>Le dépassement de capacité a lieu lorsqu'on tente d'affecter à une lvalue une valeur plus grande que ce qu'elle peut contenir. Par exemple, en affectant une valeur sur 32 bits à une variable ne pouvant contenir que 16 bits.
</p>
<h2><span class="mw-headline" id="Conversions"><span class="mw-headline-number">6.1</span> Conversions</span></h2>
<h3><span class="mw-headline" id="Implicites"><span class="mw-headline-number">6.1.1</span> Implicites</span></h3>
<p>En langage C, des règles de conversion dite implicite s'appliquent aux données qui composent une expression complexe lorsqu'ils ne sont pas de même type (entier avec un flottant, entier court avec entier long, entier signé avec un entier non signé, etc.). Par exemple, dans l'expression&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="st0">'A'</span> <span class="sy0">+</span> <span class="nu0">2</span></pre></div></div>
<p>'A' est de type char et 2 de type int. Dans ce cas, 'A' est tout d'abord converti en int avant que l'expression ne soit évaluée. Le résultat de l'opération est de type int (car un int + un int donne un int). Ici, il vaut 67 (65 + 2). En fait, les char et les short sont toujours systématiquement convertis en int c'est-à-dire que dans l'addition de deux char par exemple, tous deux sont tout d'abord convertis en int avant d'être additionnés, et le résultat est un int (pas un char). Un unsigned char sera converti en unsigned int, et ainsi de suite.
</p><p>En règle générale&#160;: le type le plus «&#160;faible&#160;» est convertit dans le type le plus «&#160;fort&#160;». Par exemple, les entiers sont plus faibles que les flottants donc 1 mélangé à un flottant par exemple sera tout d'abord converti en 1.0 avant que l'opération n'ait effectivement lieu.
</p><p>Le compilateur convertit le rang inférieur vers le rang supérieur (= promotion)&#160;:
</p>
<pre>char &lt; short &lt; int &lt; long &lt; float &lt; double
</pre>
<h3><span class="mw-headline" id="Explicites_.28cast.29"><span class="mw-headline-number">6.1.2</span> Explicites (cast)</span></h3>
<p>Il suffit de préciser le type de destination entre parenthèses devant l'expression à convertir. Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">float</span> f<span class="sy0">;</span>
f <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">float</span><span class="br0">&#41;</span><span class="nu16">3.1416</span><span class="sy0">;</span></pre></div></div>
<p>Dans cet exemple, on a converti explicitement 3.1416, qui est de type double, en float. Lorsqu'on affecte un flottant à un entier, seule la partie entière, si elle peut être représentée, est retenue.
</p>
<h1><span class="mw-headline" id="Les_instructions"><span class="mw-headline-number">7</span> Les instructions</span></h1>
<h2><span class="mw-headline" id="if"><span class="mw-headline-number">7.1</span> if</span></h2>
<p>Permet d'effectuer des choix conditionnels. La syntaxe de l'instruction est la suivante&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">&lt;</span>expression<span class="sy0">&gt;</span> <span class="br0">&#41;</span>
    <span class="sy0">&lt;</span>une et une seule instruction<span class="sy0">&gt;</span>
<span class="kw1">else</span>
    <span class="sy0">&lt;</span>une et une seule instruction<span class="sy0">&gt;</span></pre></div></div>
<p>Une instruction if peut ne pas comporter de else. Lorsqu'on a plusieurs instructions if imbriquées, un else se rapporte toujours au dernier if suivi d'une et une seule instruction. Par exemple&#160;: écrivons un programme qui compare deux nombres.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> a<span class="sy0">,</span> b<span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Ce programme compare deux nombres.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez la valeur de a&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%d&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>a<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez la valeur de b&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%d&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>b<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy0">&lt;</span> b<span class="br0">&#41;</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;a est plus petit que b.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">else</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy0">&gt;</span> b<span class="br0">&#41;</span>
            <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;a est plus grand que b.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">else</span>
            <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;a est egal a b.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h2><span class="mw-headline" id="do"><span class="mw-headline-number">7.2</span> do</span></h2>
<p>Permet d'effectuer une boucle. La syntaxe de l'instruction est la suivante&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw1">do</span>
    <span class="sy0">&lt;</span>une et une seule instruction<span class="sy0">&gt;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span> <span class="sy0">&lt;</span>expression<span class="sy0">&gt;</span> <span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>L'instruction do permet d'exécuter une instruction tant que &lt;expression&gt; est vraie. Le test est fait après chaque exécution de l'instruction. Voici un programme qui affiche 10 fois Bonjour.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> nb_lignes_affichees <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&#160;
    <span class="kw1">do</span>
        <span class="br0">&#123;</span>
            <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Bonjour.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
            nb_lignes_affichees<span class="sy0">++;</span>
        <span class="br0">&#125;</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span>nb_lignes_affichees <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h2><span class="mw-headline" id="while"><span class="mw-headline-number">7.3</span> while</span></h2>
<p>Permet d'effectuer une boucle. La syntaxe de l'instruction est la suivante&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw1">while</span> <span class="br0">&#40;</span> <span class="sy0">&lt;</span>expression<span class="sy0">&gt;</span> <span class="br0">&#41;</span>
    <span class="sy0">&lt;</span>une et une seule instruction<span class="sy0">&gt;</span></pre></div></div>
<p>L'instruction while permet d'exécuter une instruction tant que &lt;expression&gt; est vraie. Le test est fait avant chaque exécution de l'instruction. Donc si la condition (&lt;expression&gt;) est fausse dès le départ, la boucle ne sera pas exécutée. 
</p>
<h2><span class="mw-headline" id="for"><span class="mw-headline-number">7.4</span> for</span></h2>
<p>Permet d'effectuer une boucle. La syntaxe de l'instruction est la suivante&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw1">for</span> <span class="br0">&#40;</span> <span class="sy0">&lt;</span>init<span class="sy0">&gt;</span> <span class="sy0">;</span> <span class="sy0">&lt;</span>condition<span class="sy0">&gt;</span> <span class="sy0">;</span> <span class="sy0">&lt;</span>step<span class="sy0">&gt;</span><span class="br0">&#41;</span>
    <span class="sy0">&lt;</span>instruction<span class="sy0">&gt;</span></pre></div></div>
<p>Elle est pratiquement identique à&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="sy0">&lt;</span>init<span class="sy0">&gt;;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span> <span class="sy0">&lt;</span>condition<span class="sy0">&gt;</span> <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="sy0">&lt;</span>instruction<span class="sy0">&gt;</span>
    <span class="sy0">&lt;</span>step<span class="sy0">&gt;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Par exemple, écrivons un programme qui affiche la table de multiplication par 5.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> n<span class="sy0">;</span>
&#160;
    <span class="kw1">for</span><span class="br0">&#40;</span>n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> n <span class="sy0">&lt;=</span> <span class="nu0">10</span><span class="sy0">;</span> n<span class="sy0">++</span><span class="br0">&#41;</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;5 x&#160;%2d&#160;%2d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> n<span class="sy0">,</span> <span class="nu0">5</span> <span class="sy0">*</span> n<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Le format&#160;%2d permet d'afficher un entier avec 2 caractères au minimum (l'espace restant sera rempli par des espaces).
</p>
<h2><span class="mw-headline" id="break"><span class="mw-headline-number">7.5</span> break</span></h2>
<p>Permet de sortir immédiatement d'une boucle ou d'un switch. La syntaxe de cette instruction est&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw2">break</span><span class="sy0">;</span></pre></div></div>
<h2><span class="mw-headline" id="Switch_et_case"><span class="mw-headline-number">7.6</span> Switch et case</span></h2>
<p>Ces instructions permettent d'éviter des instructions if trop imbriquées comme illustré par l'exemple suivant&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> n<span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez un nombre entier&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%d&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>n<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">switch</span><span class="br0">&#40;</span>n<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
    <span class="kw1">case</span> <span class="nu0">0</span><span class="sy0">:</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Cas de 0.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw2">break</span><span class="sy0">;</span>
&#160;
    <span class="kw1">case</span> <span class="nu0">1</span><span class="sy0">:</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Cas de 1.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw2">break</span><span class="sy0">;</span>
&#160;
    <span class="kw1">case</span> <span class="nu0">2</span><span class="sy0">:</span> <span class="kw1">case</span> <span class="nu0">3</span><span class="sy0">:</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Cas de 2 ou 3.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw2">break</span><span class="sy0">;</span>
&#160;
    <span class="kw1">case</span> <span class="nu0">4</span><span class="sy0">:</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Cas de 4.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw2">break</span><span class="sy0">;</span>
&#160;
    <span class="kw1">default</span><span class="sy0">:</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Cas inconnu.<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h2><span class="mw-headline" id="Continue"><span class="mw-headline-number">7.7</span> Continue</span></h2>
<p>Dans une boucle, permet de passer immédiatement à l'itération suivante. Par exemple, modifions le programme table de multiplication de telle sorte qu'on affiche rien pour n = 4 ou n = 6.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> n<span class="sy0">;</span>
&#160;
    <span class="kw1">for</span><span class="br0">&#40;</span>n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> n <span class="sy0">&lt;=</span> <span class="nu0">10</span><span class="sy0">;</span> n<span class="sy0">++</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>n <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="sy0">||</span> <span class="br0">&#40;</span>n <span class="sy0">==</span> <span class="nu0">6</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
            <span class="kw1">continue</span><span class="sy0">;</span>
&#160;
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;5 x&#160;%2d&#160;%2d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> n<span class="sy0">,</span> <span class="nu0">5</span> <span class="sy0">*</span> n<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h2><span class="mw-headline" id="Return"><span class="mw-headline-number">7.8</span> Return</span></h2>
<p>Permet de terminer une fonction. La syntaxe de cette instruction est la suivante&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw1">return</span> <span class="sy0">&lt;</span>expression<span class="sy0">&gt;;</span> <span class="coMULTI">/* termine la fonction et retourne &lt;expression&gt; */</span></pre></div></div>
<p>ou&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw1">return</span><span class="sy0">;</span> <span class="coMULTI">/* termine la fonction sans spécifier de valeur de retour */</span></pre></div></div>
<h1><span class="mw-headline" id="Tableaux.2C_pointeurs_et_cha.C3.AEnes_de_caract.C3.A8res"><span class="mw-headline-number">8</span> Tableaux, pointeurs et chaînes de caractères</span></h1>
<p>Un tableau est une variable qui regroupe une ou plusieurs données de même type. L'accès à un élément du tableau se fait par un système d'indice, l'indice du premier élément étant 0. Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="sy0">;</span></pre></div></div>
<p>déclare un tableau de 10 éléments (de type int) dont le nom est t. Les éléments du tableau vont donc de t[0], t[1], t[2] ... à t[9]. t est une variable de type tableau, plus précisément (dans notre cas), une variable de type tableau de 10 int (int [10]). Les éléments du tableau sont des int. Toutes les règles s'appliquant aux variables s'appliquent également aux éléments d'un tableau.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> msg<span class="br0">&#91;</span> <span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">&quot;bonjour&quot;</span><span class="sy0">;</span>
<span class="kw4">char</span> msg<span class="br0">&#91;</span><span class="nu0">8</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">&quot;bonjour&quot;</span><span class="sy0">;</span> <span class="co1">// le 8 correspond au nombre de lettres du mot et bonjour plus le '\0'.</span></pre></div></div>
<h2><span class="mw-headline" id="Initialisation"><span class="mw-headline-number">8.1</span> Initialisation</span></h2>
<p>On peut initialiser un tableau à l'aide des accolades. Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">40</span><span class="sy0">,</span> <span class="nu0">50</span><span class="sy0">,</span> <span class="nu0">60</span><span class="sy0">,</span> <span class="nu0">70</span><span class="sy0">,</span> <span class="nu0">80</span><span class="sy0">,</span> <span class="nu0">90</span><span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<p>Bien évidemment, on n'est pas obligé d'initialiser tous les éléments, on aurait donc pu par exemple nous arrêter après le 5ème élément, et dans ce cas les autres éléments du tableau seront automatiquement initialisés à 0. Attention&#160;! une variable locale non initialisée contient «&#160;n'importe quoi&#160;», pas 0&#160;!
</p><p>Lorsqu'on déclare un tableau avec initialisation, on peut ne pas spécifier le nombre d'éléments car le compilateur le calculera automatiquement. Ainsi, la déclaration&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">30</span><span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<p>est strictement identique à&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">30</span><span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<h3><span class="mw-headline" id="Calculer_la_taille_d.27un_tableau"><span class="mw-headline-number">8.1.1</span> Calculer la taille d'un tableau</span></h3>
<p>La taille d'un tableau est évidemment le nombre d'éléments du tableau multiplié par la taille de chaque élément. Ainsi, le nombre d'éléments dans un tableau est égal à sa taille divisée par la taille d'un élément. On utilise alors généralement la formule sizeof(t) / sizeof(t[0]) pour connaître le nombre d'éléments d'un tableau t. La macro définie ci-dessous permet de calculer la taille d'un tableau&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define COUNT(t) (sizeof(t) / sizeof(t[0]))</span></pre></div></div>
<h2><span class="mw-headline" id="Multidimentions"><span class="mw-headline-number">8.2</span> Multidimentions</span></h2>
<p>On peut également créer un tableau à plusieurs dimensions. Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span><span class="sy0">;</span></pre></div></div>
<p>Un tableau à plusieurs dimensions n'est en fait rien d'autre qu'un tableau (tableau à une dimension) dont les éléments sont des tableaux. Comme dans le cas des tableaux à une dimension, le type des éléments du tableau doit être parfaitement connu. Ainsi dans notre exemple, t est un tableau de 10 tableaux de 3 int, ou pour vous aider à y voir plus clair&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">typedef</span> <span class="kw4">int</span> TRIPLET<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span><span class="sy0">;</span>
TRIPLET t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="sy0">;</span></pre></div></div>
<p>Les éléments de t vont de t[0] à t[9], chacun étant un tableau de 3 int.
</p><p>On peut bien entendu créer des tableaux à 3 dimensions, 4, 5, 6, ...
</p><p>On peut également initialiser un tableau à plusieurs dimensions. Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span><span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#125;</span><span class="sy0">,</span>
                <span class="br0">&#123;</span><span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">&#125;</span><span class="sy0">,</span>
                <span class="br0">&#123;</span><span class="nu0">8</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">11</span><span class="br0">&#125;</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<p>Qu'on aurait également pu tout simplement écrire&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="br0">&#93;</span><span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#125;</span><span class="sy0">,</span>
               <span class="br0">&#123;</span><span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">&#125;</span><span class="sy0">,</span>
               <span class="br0">&#123;</span><span class="nu0">8</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">11</span><span class="br0">&#125;</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<h1><span class="mw-headline" id="Arithm.C3.A9tique_des_pointeurs"><span class="mw-headline-number">9</span> Arithmétique des pointeurs</span></h1>
<h2><span class="mw-headline" id="Introduction_au_calcul_d.27adresses"><span class="mw-headline-number">9.1</span> Introduction au calcul d'adresses</span></h2>
<p>Voici un exemple de pointeur&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">t<span class="br0">&#91;</span><span class="nu0">5</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'*'</span><span class="sy0">;</span></pre></div></div>
<p>Dans la pratique, on utilise un pointeur sur un élément du tableau, généralement le premier. Cela permet d'accéder à n'importe quel élément du tableau par simple calcul d'adresse. Comme nous l'avons dit plus haut&#160;: t + 1 est équivalent à &amp;(t[1]), t + 2 à &amp;(t[2]), etc.
</p><p>Voici un exemple qui montre une manière de parcourir un tableau&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="co2">#define COUNT(t) (sizeof(t) / sizeof(t[0]))</span>
&#160;
<span class="kw4">void</span> Affiche<span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span> p<span class="sy0">,</span> <span class="kw4">size_t</span> nbElements<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">40</span><span class="sy0">,</span> <span class="nu0">50</span><span class="sy0">,</span> <span class="nu0">60</span><span class="sy0">,</span> <span class="nu0">70</span><span class="sy0">,</span> <span class="nu0">80</span><span class="sy0">,</span> <span class="nu0">90</span><span class="br0">&#125;</span><span class="sy0">;</span>
&#160;
    Affiche<span class="br0">&#40;</span>t<span class="sy0">,</span> COUNT<span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw4">void</span> Affiche<span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span> p<span class="sy0">,</span> <span class="kw4">size_t</span> nbElements<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">size_t</span> i<span class="sy0">;</span>
&#160;
    <span class="kw1">for</span><span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> nbElements<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
        <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h2><span class="mw-headline" id="L.27arithm.C3.A9tique_des_pointeurs"><span class="mw-headline-number">9.2</span> L'arithmétique des pointeurs</span></h2>
<p>L'arithmétique des pointeurs est née des faits que nous avons établis précédemment. En effet si p pointe sur un élément d'un tableau, p + 1 doit pointer sur l'élément suivant. Donc si la taille de chaque élément du tableau est par exemple de 4, p + 1 déplace le pointeur de 4 octets (où se trouve l'élément suivant) et non de un.
</p><p>De même, puisque l'on devrait avoir (p + 1) - p = 1 et non 4, la différence entre deux adresses donne le nombre d'éléments entre ces adresses et non le nombre d'octets entre ces adresses. Le type d'une telle expression est <b>ptrdiff_t</b>, qui est défini dans le fichier <b>stddef.h</b>.
</p><p>Et enfin, l'écriture p[i] est strictement équivalente à *(p + i).
</p><p>Cela montre à quel point le typage des pointeurs est important. Cependant, il existe des pointeurs dits génériques capables de pointer sur n'importe quoi. Ainsi, la conversion d'un pointeur générique en un pointeur d'un autre type par exemple ne requiert aucun cast et vice versa. 
</p>
<h2><span class="mw-headline" id="Pointeurs_g.C3.A9n.C3.A9riques"><span class="mw-headline-number">9.3</span> Pointeurs génériques</span></h2>
<p>Le type des pointeurs génériques est void *. Comme ces pointeurs sont génériques, la taille des données pointées est inconnue et l'arithmétique des pointeurs ne s'applique donc pas à eux. De même, puisque la taille des données pointées est inconnue, l'opérateur d'indirection * ne peut être utilisé avec ces pointeurs, un cast est alors obligatoire. Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n<span class="sy0">;</span>
<span class="kw4">void</span> <span class="sy0">*</span> p<span class="sy0">;</span>
&#160;
p <span class="sy0">=</span> <span class="sy0">&amp;</span>n<span class="sy0">;</span>
<span class="sy0">*</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span><span class="br0">&#41;</span>p<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span> <span class="coMULTI">/* p etant desormais vu comme un int *, on peut alors lui appliquer l'operateur *. */</span></pre></div></div>
<p>Etant donné que la taille de toute donnée est multiple de celle d'un char, le type char * peut être également utilisé en tant que pointeur universel. En effet, une variable de type char * est un pointeur sur octet autrement dit peut pointer n'importe quoi. Cela s'avère pratique des fois (lorsqu'on veut lire le contenu d'une mémoire octet par octet par exemple) mais dans la plupart des cas, il vaut mieux toujours utiliser les pointeurs génériques. Par exemple, la conversion d'une adresse de type différent en char * et vice versa nécessite toujours un cast, ce qui n'est pas le cas avec les pointeurs génériques.
</p><p>Dans printf, le spécificateur de format&#160;%p permet d'imprimer une adresse (void *) dans le format utilisé par le système.
</p><p>Et pour terminer, il existe une macro à savoir NULL, définie dans stddef.h, permettant d'indiquer q'un pointeur ne pointe nulle part. Son intérêt est donc de permettre de tester la validité d'un pointeur et il est conseillé de toujours initialiser un pointeur à NULL.
</p>
<h2><span class="mw-headline" id="Exemple_avec_un_tableau_.C3.A0_plusieurs_dimensions"><span class="mw-headline-number">9.4</span> Exemple avec un tableau à plusieurs dimensions</span></h2>
<p>Soit&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span><span class="sy0">;</span></pre></div></div>
<p>Définissons le type TRIPLET par&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">typedef</span> <span class="kw4">int</span> TRIPLET<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span><span class="sy0">;</span></pre></div></div>
<p>De façon à avoir&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">TRIPLET t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="sy0">;</span></pre></div></div>
<p>Vu d'un pointeur, t représente l'adresse de t[0] (qui est un TRIPLET) donc l'adresse d'un TRIPLET. En faisant t + 1, on se déplace donc d'un TRIPLET soit de 3 int.
</p><p>D'autre part, t peut être vu comme un tableau de 30 int (3 * 10 = 30), on peut donc accéder à n'importe quel élément de t à l'aide d'un pointeur sur int.
</p><p>Soit p un pointeur sur int et faisons&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">p <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy0">*</span><span class="br0">&#41;</span>t<span class="sy0">;</span></pre></div></div>
<p>On a alors, numériquement, les équivalences suivantes&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">t 	p
t <span class="sy0">+</span> <span class="nu0">1</span> 	p <span class="sy0">+</span> <span class="nu0">3</span>
t <span class="sy0">+</span> <span class="nu0">2</span> 	p <span class="sy0">+</span> <span class="nu0">6</span>
... 	 
<span class="me1">t</span> <span class="sy0">+</span> <span class="nu0">9</span> 	p <span class="sy0">+</span> <span class="nu0">27</span></pre></div></div>
<p>Prenons alors à présent, le 3ème TRIPLET de t soit t[2].
</p><p>Puisque le premier élément de t[2] se trouve à l'adresse t + 2 soit p + 6, deuxième se trouve en p + 6 +1 et le troisième et dernier en p + 6 + 2. A près cet entier, on se retrouve au premier élément de t[3], en p + 9.
</p><p>En conclusion, pour un tableau déclaré&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="sy0">&lt;</span>type<span class="sy0">&gt;</span> t<span class="br0">&#91;</span>N<span class="br0">&#93;</span><span class="br0">&#91;</span>M<span class="br0">&#93;</span><span class="sy0">;</span></pre></div></div>
<p>on a la formule&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">t<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="sy0">*</span><span class="br0">&#40;</span>p <span class="sy0">+</span> N<span class="sy0">*</span>i <span class="sy0">+</span> j<span class="br0">&#41;</span> <span class="coMULTI">/* ou encore p[N*i + j] */</span></pre></div></div>
<p>Où évidemment&#160;: p = (int *)t.
</p><p>Et on peut bien sur étendre cette formule pour n'importe quelle dimension. 
</p>
<h1><span class="mw-headline" id="Les_cha.C3.AEnes_de_caract.C3.A8res"><span class="mw-headline-number">10</span> Les chaînes de caractères</span></h1>
<p>Par définition, une chaîne de caractères, ou tout simplement&#160;: chaîne, est une suite finie de caractères. Par exemple, "Bonjour", "3000", "Salut&#160;!", "EN 4", ... sont des chaînes de caractères. En langage C, une constante de type chaîne de caractères s'écrit entre double quottes, exactement comme dans les exemples donnés ci-dessus.
</p><p>La longueur d'une chaîne est le nombre de caractères qu'elle comporte. Par exemple, la chaîne "Bonjour" comporte 7 caractères ('B', 'o', 'n', 'j', 'o', 'u' et 'r'). Sa longueur est donc 7. En langage C, la fonction strlen, déclarée dans le fichier string.h, permet d'obtenir la longueur d'une chaîne passée en argument. Ainsi, strlen("Bonjour") vaut 7.
</p>
<h2><span class="mw-headline" id="Repr.C3.A9sentation_des_cha.C3.AEnes_de_caract.C3.A8res_en_langage_C"><span class="mw-headline-number">10.1</span> Représentation des chaînes de caractères en langage C</span></h2>
<p>Comme nous l'avons déjà mentionné plus haut, les constantes de type chaîne de caractères s'écrit en langage C entre double quottes. En fait, le langage C ne dispose pas vraiment de type chaîne de caractères. Une chaîne est tout simplement représentée à l'aide d'un tableau de caractères.
</p><p>Cependant, les fonctions manipulant des chaînes doivent être capables de détecter la fin d'une chaîne donnée. Autrement dit, toute chaîne de caractères doit se terminer par un caractère indiquant la fin de la chaîne. Ce caractère est le caractère '\0' et est appelé le caractère nul ou encore caractère de fin de chaîne. Son code ASCII est 0. Ainsi la chaîne "Bonjour" est en fait un tableau de caractères dont les éléments sont 'B', 'o', 'n', 'j', 'o', 'u', 'r', '\0', autrement dit un tableau de 8 caractères et on a donc "Bonjour"[0] = 'B', "Bonjour"[1] = 'o', "Bonjour"[2] = 'n', ... "Bonjour"[7] = '\0'. Toutefois, comme il s'agit d'une constante (constante chaîne de caractères), le contenu de la mémoire allouée pour la chaîne "Bonjour" ne peut être modifié.
</p><p><b>Les fonctions de manipulation de chaîne de la bibliothèque standard du langage C sont principalement déclarées dans le fichier string.h. Voici un exemple d'utilisation d'une de ces fonctions&#160;:</b>
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;string.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> t<span class="br0">&#91;</span><span class="nu0">50</span><span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">strcpy</span><span class="br0">&#40;</span>t<span class="sy0">,</span> <span class="st0">&quot;Hello, world!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;%s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> t<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Dans cet exemple, la chaîne t ne peut contenir tout au plus que 50 caractères, caractère de fin de chaîne inclus. Autrement dit <b>t ne peut que contenir 49 caractères</b> «&#160;normaux&#160;» car il faut toujours réserver une place pour le caractère de fin de chaîne&#160;: '\0'. On peut aussi bien sûr initialiser une chaîne au moment de sa déclaration, par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> s<span class="br0">&#91;</span><span class="nu0">50</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">&quot;Bonjour&quot;</span><span class="sy0">;</span></pre></div></div>
<p>Qui est strictement équivalente à&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> s<span class="br0">&#91;</span><span class="nu0">50</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'B'</span><span class="sy0">,</span> <span class="st0">'o'</span><span class="sy0">,</span> <span class="st0">'n'</span><span class="sy0">,</span> <span class="st0">'j'</span><span class="sy0">,</span> <span class="st0">'o'</span><span class="sy0">,</span> <span class="st0">'u'</span><span class="sy0">,</span> <span class="st0">'r'</span><span class="sy0">,</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<p>Puisque, vu d'un pointeur, la valeur d'une expression littérale de type chaîne n'est autre que l'adresse de son premier élément, on peut utiliser un simple pointeur pour manipuler une chaîne. Par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> <span class="sy0">*</span> p <span class="sy0">=</span> <span class="st0">&quot;Bonjour&quot;</span><span class="sy0">;</span></pre></div></div>
<p>Dans ce cas, p pointe sur le premier élément de la chaîne "Bonjour". Or, comme nous l'avons déjà dit plus haut, la mémoire allouée pour la chaîne "Bonjour" est en lecture seule donc on ne peut pas écrire par exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">p<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'*'</span><span class="sy0">;</span> <span class="coMULTI">/* Interdit */</span></pre></div></div>
<p>Avec un tableau, ce n'est pas l'adresse en mémoire de la chaîne qui est stockée, mais les caractères de la chaîne, copiés caractère par caractère. La mémoire utilisée par le tableau étant indépendante de celle utilisée par la chaîne source, on peut faire ce qu'on veut de notre tableau. La fonction strcpy permet de copier une chaîne vers un autre emplacement mémoire.
</p><p>Le paragraphe suivant discute des fonctions de manipulation de chaînes en langage C.
</p>
<h2><span class="mw-headline" id="strcpy.2C_strncpy"><span class="mw-headline-number">10.2</span> strcpy, strncpy</span></h2>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;string.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> t1<span class="br0">&#91;</span><span class="nu0">50</span><span class="br0">&#93;</span><span class="sy0">,</span> t2<span class="br0">&#91;</span><span class="nu0">50</span><span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">strcpy</span><span class="br0">&#40;</span>t1<span class="sy0">,</span> <span class="st0">&quot;Hello, world!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">strcpy</span><span class="br0">&#40;</span>t2<span class="sy0">,</span> <span class="st0">&quot;*************&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">strncpy</span><span class="br0">&#40;</span>t1<span class="sy0">,</span> t2<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;%s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> t1<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Attention&#160;! Si t1 n'est pas assez grand pour pouvoir contenir la chaîne à copier, vous aurez un <b>débordement de tampon (buffer overflow)</b>. Un tampon (ou buffer) est tout simplement une zone de la mémoire utilisée par un programme pour stocker temporairement des données. Par exemple, t1 est un buffer de 50 octets. Il est donc de la responsabilité du programmeur de ne pas lui passer n'importe quoi&#160;! En effet en C, le compilateur suppose que le programmeur sait ce qu'il fait&#160;!
</p><p>La fonction strncpy s'utilise de la même manière que strcpy. Le troisième argument indique le nombre de caractères à copier. Aucun caractère de fin de chaîne n'est automatiquement ajouté. 
</p>
<h2><span class="mw-headline" id="strcat.2C_strncat"><span class="mw-headline-number">10.3</span> strcat, strncat</span></h2>
<p>Ceci va donc rajouter à la suite d'un tableau des caractères&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;string.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> t<span class="br0">&#91;</span><span class="nu0">50</span><span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">strcpy</span><span class="br0">&#40;</span>t<span class="sy0">,</span> <span class="st0">&quot;Hello, world&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">strcat</span><span class="br0">&#40;</span>t<span class="sy0">,</span> <span class="st0">&quot; from&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">strcat</span><span class="br0">&#40;</span>t<span class="sy0">,</span> <span class="st0">&quot; strcpy&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">strcat</span><span class="br0">&#40;</span>t<span class="sy0">,</span> <span class="st0">&quot; and strcat&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;%s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> t<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Ce qui donnera&#160;:
</p>
<pre>Hello, world from strcpy and strcat
</pre>
<h2><span class="mw-headline" id="strlen"><span class="mw-headline-number">10.4</span> strlen</span></h2>
<p>Retourne le nombre de caractères d'une chaîne.
</p>
<h2><span class="mw-headline" id="strcmp.2C_strncmp"><span class="mw-headline-number">10.5</span> strcmp, strncmp</span></h2>
<p>On n'utilise pas l'opérateur == pour comparer des chaînes car ce n'est pas les adresses qu'on veut comparer mais le contenu mémoire. La fonction strcmp compare deux chaînes de caractères et retourne&#160;:
</p>
<ul><li> zéro si les chaînes sont identiques</li>
<li> un nombre négatif si la première est "inférieure" (du point de vue lexicographique) à la seconde</li>
<li> et un nombre positif si la première est "supérieure" (du même point de vue ...) à la seconde</li></ul>
<p>Ainsi, à titre d'exemple, dans l'expression
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw3">strcmp</span><span class="br0">&#40;</span><span class="st0">&quot;clandestin&quot;</span><span class="sy0">,</span> <span class="st0">&quot;clavier&quot;</span><span class="br0">&#41;</span></pre></div></div>
<p>La fonction retourne un nombre négatif car, 'n' étant plus petit que 'v' (dans le jeu de caractères ASCII, ça n'a rien à voir avec le langage C), "clandestin" est plus petit que "clavier". 
</p>
<h2><span class="mw-headline" id="Impl.C3.A9mentation_de_quelques_fonctions_de_manipulation_de_cha.C3.AEne"><span class="mw-headline-number">10.6</span> Implémentation de quelques fonctions de manipulation de chaîne</span></h2>
<p>Nous allons donc implémenter deux fonctions de manipulation de chaîne à savoir str_len et str_cpy, qui s'utiliseront de la même manière que leurs bessons strlen et strcpy.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">size_t</span> str_len<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span> t<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">size_t</span> len<span class="sy0">;</span>
&#160;
    <span class="kw1">for</span><span class="br0">&#40;</span>len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> t<span class="br0">&#91;</span>len<span class="br0">&#93;</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">&#41;</span>
        <span class="coMULTI">/* On ne fait rien, on laisse seulement boucler */</span> <span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> <span class="sy0">*</span> str_cpy<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span> dest<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span> source<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> i<span class="sy0">;</span>
&#160;
    <span class="kw1">for</span><span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> source<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
        dest<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> source<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    dest<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> dest<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Remarquez bien la manière dont nous avons implémenté la fonction str_cpy. Vous vous attendiez peut-être à ce que cette fonction retourne void et non un char *. Et bien non&#160;! De nombreuses fonctions de la bibliothèque standard utilisent également cette «&#160;convention&#160;», ce qui permet d'écrire du code du genre&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> s<span class="br0">&#91;</span><span class="nu0">50</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">&quot;Bonjour&quot;</span><span class="sy0">;</span>
<span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;%s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> <span class="kw3">strcat</span><span class="br0">&#40;</span>s<span class="sy0">,</span> <span class="st0">&quot; tout le monde&#160;!&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>Les entrées/sorties (E/S) ne font pas vraiment partie du langage C car ces opérations sont dépendantes du système. Donc pour réaliser des opérations d'entrée/sortie en langage C il faut en principe passer par les fonctionnalités de bas niveau du système. Néanmoins sa bibliothèque standard est fournie avec des fonctions permettant d'effectuer de telles opérations afin de faciliter l'écriture de code portable. Les fonctions et types de données liées aux entrées/sorties sont principalement déclarés dans le fichier stdio.h (standard input/output).
</p><p>Les entrées/sorties en langage C se font par l'intermédiaire d'entités logiques, appelés flux, qui représentent des objets externes au programme, appelés fichiers. Un fichier peut être ouvert en lecture, auquel cas il est censé nous fournir des données (c'est-à-dire être lu) ou ouvert en écriture, auquel cas il est destiné à recevoir des données provenant du programme. Un fichier peut être à la fois ouvert en lecture et en écriture. Une fois qu'un fichier est ouvert, un flux lui est associé. Un flux d'entrée est un flux associé à un fichier ouvert en lecture et un flux de sortie un flux associé à un fichier ouvert un écriture.
</p><p>Lorsque les données échangées entre le programme et le fichier sont de type texte, la nécessité de définir ce qu'on appelle une ligne est primordiale. En langage C, une ligne est une suite de caractères terminée par le caractère de fin de ligne (inclus)&#160;: '\n'. Par exemple, lorsqu'on effectue des saisies au clavier, une ligne correspond à une suite de caractères terminée par ENTREE. Puisque la touche ENTREE termine une ligne, le caractère généré par l'appui de cette touche est donc, en C standard, le caractère de fin de ligne soit '\n'.
</p><p>Lorsque le système exécute un programme, trois fichiers sont automatiquement ouverts&#160;:
</p>
<ul><li> l'entrée standard par défaut le clavier</li>
<li> la sortie standard, par défaut l'écran (ou la console)</li>
<li> et l'erreur standard, par défaut associé à l'écran (ou la console)</li></ul>
<p>Vous connaissez la suite, pour les redirections dans des fichiers (&lt; &gt;).
</p>
<h2><span class="mw-headline" id="lire_un_caract.C3.A8re.2C_puis_l.27afficher"><span class="mw-headline-number">10.7</span> lire un caractère, puis l'afficher</span></h2>
<p>La macro getc permet de lire un caractère sur un flux d'entrée. La macro putc permet d'écrire un caractère sur un flux de sortie. Voici un programme simple qui montre comment utiliser les macros getc et putc&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> c<span class="sy0">;</span> <span class="coMULTI">/* le caractere */</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Veuillez taper un caractere&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    c <span class="sy0">=</span> <span class="kw3">getc</span><span class="br0">&#40;</span>stdin<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Vous avez tape&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">putc</span><span class="br0">&#40;</span>c<span class="sy0">,</span> stdout<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Vous vous demandez certainement la raison pour laquelle on a utilisé int plutôt que char dans la déclaration de c. Et bien tout simplement parce que getc retourne un int (de même putc attend un argument de type int). Mais justement&#160;: Pourquoi&#160;? Et bien parce que getc doit pouvoir non seulement retourner le caractère lu (un char) mais aussi une valeur qui ne doit pas être un char pour signaler qu'aucun caractère n'a pu être lu. <b>Cette valeur est EOF. Elle est définie dans le fichier stdio.h</b>. Dans ces conditions, il est clair qu'on peut utiliser tout sauf un char comme type de retour de getc.
</p><p>Un des cas les plus fréquents où getc retourne EOF est lorsqu'on a rencontré la fin du fichier. La fin d'un fichier est un point situé au-delà du dernier caractère de ce fichier (si le fichier est vide, le début et la fin du fichier sont donc confondus). On dit qu'on a rencontré la fin d'un fichier après avoir encore tenté de lire dans ce fichier alors qu'on se trouve déjà à la fin, pas juste après avoir lu le dernier caractère. Lorsque stdin est associé au clavier, la notion de fin de fichier perd à priori son sens car l'utilisateur peut très bien taper n'importe quoi à n'importe quel moment. Cependant l'environnement d'exécution (le système d'exploitation) offre généralement un moyen de spécifier qu'on n'a plus aucun caractère à fournir (concrètement, pour nous, cela signifie que getc va retourner EOF). Sous Windows par exemple, il suffit de taper en début de ligne la combinaison de touches Ctrl + Z (héritée du DOS) puis de valider par ENTREE. Evidemment, tout recommence à zéro à la prochaine opération de lecture.
</p><p>Les macros getchar et putchar s'utilisent comme getc et putc sauf qu'elles n'opèrent que sur stdin, respectivement stdout. Elles sont définies dans stdio.h comme suit&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define getchar() getc(stdin)</span>
<span class="co2">#define putchar(c) putc(c, stdout)</span></pre></div></div>
<p>Et enfin fgetc est une fonction qui fait la même chose que getc (qui peut être en fait une fonction ou une macro ...). De même fputc est une fonction qui fait la même chose que putc. 
</p>
<h2><span class="mw-headline" id="Saisir_une_cha.C3.AEne_de_caract.C3.A8res"><span class="mw-headline-number">10.8</span> Saisir une chaîne de caractères</span></h2>
<p>Il suffit de lire les caractères présents sur le flux d'entrée (dans notre cas&#160;: stdin) jusqu'à ce que l'on ait atteint la fin du fichier ou le caractère de fin de ligne. Nous devrons fournir en arguments de la fonction l'adresse du tampon destiné à contenir la chaîne de caractère saisie et la taille de ce tampon pour supprimer le risque de débordement de tampon.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">char</span> <span class="sy0">*</span> saisir_chaine<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span> lpBuffer<span class="sy0">,</span> <span class="kw4">size_t</span> nBufSize<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> lpBuffer<span class="br0">&#91;</span><span class="nu0">20</span><span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez une chaine de caracteres&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    saisir_chaine<span class="br0">&#40;</span>lpBuffer<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>lpBuffer<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Vous avez tape&#160;:&#160;%s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> lpBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw4">char</span> <span class="sy0">*</span> saisir_chaine<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span> lpBuffer<span class="sy0">,</span> <span class="kw4">size_t</span> nBufSize<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">size_t</span> nbCar <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>    
    <span class="kw4">int</span> c<span class="sy0">;</span>
&#160;
    c <span class="sy0">=</span> <span class="kw3">getchar</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>nbCar <span class="sy0">&lt;</span> nBufSize <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span>c <span class="sy0">!=</span> EOF<span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span>c <span class="sy0">!=</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        lpBuffer<span class="br0">&#91;</span>nbCar<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">char</span><span class="br0">&#41;</span>c<span class="sy0">;</span>
        nbCar<span class="sy0">++;</span>
        c <span class="sy0">=</span> <span class="kw3">getchar</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&#160;
    lpBuffer<span class="br0">&#91;</span>nbCar<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> lpBuffer<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>La fonction scanf permet également de saisir une chaîne de caractères ne comportant aucun espace (espace, tabulation, etc.) grâce au spécificateur de format&#160;%s. Elle va donc arrêter la lecture à la rencontre d'un espace (mais avant d'effectuer la lecture, elle va d'abord avancer jusqu'au premier caractère qui n'est pas un espace). scanf ajoute enfin le caractère de fin de chaîne. Le gabarit permet d'indiquer le nombre maximum de caractères à lire (caractère de fin de chaîne non compris). Lorsqu'on utilise scanf avec le spécificateur&#160;%s (qui demande de lire une chaîne sans espace), il ne faut jamais oublier de spécifier également le nombre maximum de caractères à lire (à mettre juste devant le s) sinon le programme sera ouvert aux attaques par débordement de tampon. Voici un exemple qui montre l'utilisation de scanf avec le spécicateur de format&#160;%s&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> lpBuffer<span class="br0">&#91;</span><span class="nu0">20</span><span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez une chaine de caracteres&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%19s&quot;</span><span class="sy0">,</span> lpBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Vous avez tape&#160;:&#160;%s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> lpBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Et enfin, il existe également une fonction, gets, déclarée dans stdio.h, qui permet de lire une chaîne de caractères sur stdin. Cependant cette fonction est à proscrire car elle ne permet pas de spécifier la taille du tampon qui va recevoir la chaîne lue. 
</p>
<h2><span class="mw-headline" id="Lire_une_ligne_avec_fgets"><span class="mw-headline-number">10.9</span> Lire une ligne avec fgets</span></h2>
<p>La fonction fgets permet de lire une ligne (c'est-à-dire y compris le '\n') sur un flux d'entrée et de placer les caractères lus dans un buffer. Cette fonction ajoute ensuite le caractère '\0'. Exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> lpBuffer<span class="br0">&#91;</span><span class="nu0">20</span><span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez une chaine de caracteres&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">fgets</span><span class="br0">&#40;</span>lpBuffer<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>lpBuffer<span class="br0">&#41;</span><span class="sy0">,</span> stdin<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Vous avez tape&#160;:&#160;%s&quot;</span><span class="sy0">,</span> lpBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Dans cet exemple, deux cas peuvent se présenter&#160;:
</p>
<ul><li> l'utilisateur entre une chaîne comportant 18 caractères tout au plus puis valide le tout par ENTREE, alors tous les caractères de la ligne, y compris le caractère de fin de ligne, sont copiés dans lpBuffer puis le caractère de fin de chaîne est ajouté</li>
<li> l'utilisateur entre une chaîne comportant plus de 18 caractères (c'est-à-dire &gt;= 19) puis valide le tout par ENTREE, alors seuls les 19 premiers caractères sont copiés vers lpBuffer puis le caractère de fin de chaîne est ajouté</li></ul>
<h2><span class="mw-headline" id="M.C3.A9canisme_des_entr.C3.A9es.2Fsorties_en_langage_C"><span class="mw-headline-number">10.10</span> Mécanisme des entrées/sorties en langage C</span></h2>
<p>Les entrées/sorties en langage C sont bufférisées, c'est-à-dire que les données à lire (respectivement à écrire) ne sont pas directement lues (respectivement écrites) mais sont tout d'abord placées dans un buffer associé au fichier. La preuve, vous avez certainement remarqué par exemple que lorsque vous entrez des données pour la première fois à l'aide du clavier, ces données ne seront lues qu'une fois que vous aurez appuyé sur la touche ENTREE. Ensuite, toutes les opérations de lecture qui suivent se feront immédiatement tant que le caractère '\n' est encore présent dans le tampon de lecture, c'est-à-dire tant qu'il n'a pas été encore lu. Lorsque le caractère '\n' n'est plus présent dans le buffer, vous devrez à nouveau appuyer sur ENTREE pour valider la saisie, et ainsi de suite.
</p><p>Les opérations d'écriture sont moins compliquées, mais il y a quand même quelque chose dont il serait totalement injuste de ne pas en parler. Comme nous l'avons déjà dit plus haut, les entrées/sorties en langage C sont bufferisées c'est-à-dire passent par un tampon. Dans le cas d'une opération d'écriture, il peut arriver que l'on souhaite à un certain moment forcer l'écriture physique des données présentes dans le tampon associé au fichier sans attendre que le système se décide enfin de le faire. Dans ce cas, on utilisera la fonction fflush&#160;:<br />
Dans le cas d'un flot de sortie, cette fonction provoque l'écriture physique immédiate du tampon en cours de remplissage. Elle rend EOF en cas d'erreur, zéro dans les autres cas.
D'après la norme officielle du langage C, l'effet de fflush sur un flot qui n'est pas un flot de sortie est indéfini. Mais pour la plupart des bibliothèques actuelles, l'appel de cette fonction sur un flot d'entrée supprime les caractères disponibles dans le tampon. Par exemple, dans le cas fréquent où l'entrée standard correspond au clavier, l'appel fflush(stdin) fait disparaître tous les caractères déjà tapés mais pas encore lus par le programme.
</p><p>Remarque. Si le fichier physique qui correspond au flot indiqué est un organe interactif, par exemple l'écran d'un poste de travail, alors la fonction fflush est implicitement appelée dans deux circonstances très fréquentes&#160;:
</p>
<ul><li> l'écriture du caractère '\n' qui produit l'émission d'une marque de fin de ligne et la vidange effective du tampon,</li>
<li> le début d'une opération de lecture sur l'unité d'entrée associée (les organes d'entrée-sortie interactifs forment généralement des couples)&#160;; ainsi, par exemple, une lecture au clavier provoque la vidange du tampon d'écriture à l'écran. Cela permet qu'une question soit effectivement affichée avant que l'utilisateur ne doive taper la réponse correspondante.</li></ul>
<h3><span class="mw-headline" id="Lire_de_mani.C3.A8re_s.C3.BBre_des_donn.C3.A9es_sur_l.27entr.C3.A9e_standard"><span class="mw-headline-number">10.10.1</span> Lire de manière sûre des données sur l'entrée standard</span></h3>
<p>Tout d'abord, analysons le tout petit programme suivant&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> nom<span class="br0">&#91;</span><span class="nu0">12</span><span class="br0">&#93;</span><span class="sy0">,</span> prenom<span class="br0">&#91;</span><span class="nu0">12</span><span class="br0">&#93;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez votre nom&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">fgets</span><span class="br0">&#40;</span>nom<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>nom<span class="br0">&#41;</span><span class="sy0">,</span> stdin<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez votre prenom&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">fgets</span><span class="br0">&#40;</span>prenom<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>prenom<span class="br0">&#41;</span><span class="sy0">,</span> stdin<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Votre nom est&#160;:&#160;%s&quot;</span><span class="sy0">,</span> nom<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Et votre prenom&#160;:&#160;%s&quot;</span><span class="sy0">,</span> prenom<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Dans ce programme, si l'utilisateur entre un nom comportant moins de 10 caractères puis valide par ENTREE, alors tous les caractères rentrent dans nom et le programme se déroule bien comme prévu. Par contre si l'utilisateur entre un nom comportant plus de 10 caractères, seuls les 11 premiers caractères seront copiés dans nom et des caractères sont donc encore présents dans le buffer du clavier. Donc, à la lecture du prénom, les caractères encore présents dans le buffer seront immédiatement lus sans que l'utilisateur n'ait pu entrer quoi que ce soit. Voici un deuxième exemple&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> n<span class="sy0">;</span>
    <span class="kw4">char</span> c<span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez un nombre (entier)&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%d&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>n<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Entrez un caractere&#160;: &quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">scanf</span><span class="br0">&#40;</span><span class="st0">&quot;%c&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>c<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Le nombre que vous ave entre est&#160;:&#160;%d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> n<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span><span class="st0">&quot;Le caractere que vous ave entre est&#160;:&#160;%c<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> c<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Lorsqu'on demande à scanf de lire un nombre, elle va déplacer le pointeur jusqu'au premier caractère non blanc, lire tant qu'elle doit lire les caractères pouvant figurer dans l'expression d'un nombre, puis s'arrêter à la rencontre d'un caractère invalide (espace ou lettre par exemple).
</p><p>Donc dans l'exemple ci-dessus, la lecture du caractère se fera sans l'intervention de l'utilisateur à cause de la présence du caractère '\n' (qui sera alors le caractère lu) due à la touche ENTREE frappée pendant la saisie du nombre.
</p><p>Ces exemples nous montrent bien que d'une manière générale, il faut toujours vider le buffer du clavier après chaque saisie, sauf si celui-ci est déjà vide bien sûr. Pour vider le buffer du clavier, il suffit de manger tous les caractères présents dans le buffer jusqu'à ce qu'on ait rencontré le caractère de fin de ligne ou atteint la fin du fichier. A titre d'exemple, voici une version améliorée (avec vidage du tampon d'entrée après lecture) de notre fonction saisir_chaine&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> <span class="sy0">*</span> saisir_chaine<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span> lpBuffer<span class="sy0">,</span> <span class="kw4">int</span> nBufSize<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">char</span> <span class="sy0">*</span> p<span class="sy0">;</span>
&#160;
    <span class="kw3">fgets</span><span class="br0">&#40;</span>lpBuffer<span class="sy0">,</span> nBufSize<span class="sy0">,</span> stdin<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    p <span class="sy0">=</span> lpBuffer <span class="sy0">+</span> <span class="kw3">strlen</span><span class="br0">&#40;</span>lpBuffer<span class="br0">&#41;</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">*</span>p <span class="sy0">==</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="br0">&#41;</span>
        <span class="sy0">*</span>p <span class="sy0">=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span> <span class="coMULTI">/* on écrase le \n */</span>
    <span class="kw1">else</span>
    <span class="br0">&#123;</span>
        <span class="coMULTI">/* On vide le tampon de lecture du flux stdin */</span>
        <span class="kw4">int</span> c<span class="sy0">;</span>
&#160;
        c <span class="sy0">=</span> <span class="kw3">getchar</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">while</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>c <span class="sy0">!=</span> EOF<span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span>c <span class="sy0">!=</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
           c <span class="sy0">=</span> <span class="kw3">getchar</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&#160;
    <span class="kw1">return</span> lpBuffer<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h1><span class="mw-headline" id="L.27allocation_dynamique_de_m.C3.A9moire"><span class="mw-headline-number">11</span> L'allocation dynamique de mémoire</span></h1>
<p>L'intérêt d'allouer dynamiquement de la mémoire se ressent lorsqu'on veut créer un tableau dont la taille dont nous avons besoin n'est connue qu'à l'exécution par exemple. Autrement dit&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> t<span class="br0">&#91;</span><span class="nu0">10</span><span class="br0">&#93;</span><span class="sy0">;</span>
...
<span class="coMULTI">/* FIN */</span></pre></div></div>
<p>Peut être remplacé par&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> <span class="sy0">*</span> p<span class="sy0">;</span>
&#160;
p <span class="sy0">=</span> <span class="kw3">malloc</span><span class="br0">&#40;</span><span class="nu0">10</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
...
<span class="kw3">free</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy0">;</span> <span class="coMULTI">/* libérer la mémoire lorsqu'on n'en a plus besoin */</span>
<span class="coMULTI">/* FIN */</span></pre></div></div>
<p>Les fonctions malloc et free sont déclarées dans le fichier stdlib.h. malloc retourne NULL en cas d'échec. Voici un exemple qui illustre une bonne manière de les utiliser&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">p <span class="sy0">=</span> <span class="kw3">malloc</span><span class="br0">&#40;</span><span class="nu0">10</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>p <span class="sy0">!=</span> NULL<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    ...
    <span class="kw3">free</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="kw1">else</span>
    <span class="coMULTI">/* ECHEC */</span></pre></div></div>
<p>La fonction realloc&#160;:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">void</span> <span class="sy0">*</span> <span class="kw3">realloc</span><span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span> memblock<span class="sy0">,</span> <span class="kw4">size_t</span> newsize<span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>permet de «&#160;redimensionner&#160;» une mémoire allouée dynamiquement (par malloc par exemple). Si memblock vaut NULL, realloc se comporte comme malloc. En cas de réussite, cette fonction retourne alors l'adresse de la nouvelle mémoire, sinon la valeur NULL est retournée et la mémoire pointée par memblock reste inchangée.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> <span class="sy0">*</span> p<span class="sy0">,</span> <span class="sy0">*</span> q<span class="sy0">;</span> <span class="coMULTI">/* q&#160;: pour tester le retour de realloc */</span>
&#160;
p <span class="sy0">=</span> <span class="kw3">malloc</span><span class="br0">&#40;</span><span class="nu0">10</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>p <span class="sy0">!=</span> NULL<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    ...
&#160;
    <span class="me1">q</span> <span class="sy0">=</span> <span class="kw3">realloc</span><span class="br0">&#40;</span>p<span class="sy0">,</span> <span class="nu0">20</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
    <span class="kw1">if</span> <span class="br0">&#40;</span>q <span class="sy0">!=</span> NULL<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        p <span class="sy0">=</span> q<span class="sy0">;</span>
&#160;
        ...
    <span class="br0">&#125;</span>
&#160;
    <span class="kw3">free</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&#160;
...</pre></div></div>
<h1><span class="mw-headline" id="Ressources"><span class="mw-headline-number">12</span> Ressources</span></h1>
<p><a rel="nofollow" class="external free" href="http://c.developpez.com/cours">http://c.developpez.com/cours</a><br />
<a rel="nofollow" class="external text" href="http://books.google.fr/books?id=dsfXx4ESnM8C&amp;printsec=frontcover">C en Action - O'Reilly</a>
</p>
<!-- 
NewPP limit report
CPU time usage: 0.284 seconds
Real time usage: 0.286 seconds
Preprocessor visited node count: 1271/1000000
Preprocessor generated node count: 2532/1000000
Post‐expand include size: 181/2097152 bytes
Template argument size: 44/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.932      1 - -total
100.00%    0.932      1 - Template:Command
-->

<!-- Saved in parser cache with key blocnotesinfo-wiki_:pcache:idhash:2906-0!*!*!1!en!5!* and timestamp 20181111230829 and revision id 9465
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wiki.deimos.fr/index.php?title=Introduction_au_C&amp;oldid=9465">https://wiki.deimos.fr/index.php?title=Introduction_au_C&amp;oldid=9465</a>"					</div>
													<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://wiki.deimos.fr/index.php?title=Special:UserLogin&amp;returnto=Introduction+au+C" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="Introduction_au_C.html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="Introduction_au_C.html#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="Introduction_au_C.html" >Read</a></span></li>
															<li id="ca-viewsource"><span><a href="https://wiki.deimos.fr/index.php?title=Introduction_au_C&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="https://wiki.deimos.fr/index.php?title=Introduction_au_C&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="Introduction_au_C.html#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="https://wiki.deimos.fr/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search Deimos.fr / Bloc Notes Informatique [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a style="background-image: url(images/a/a7/Logo_deimosfr.png);" href="index.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation_et_RSS' aria-labelledby='p-navigation_et_RSS-label'>
			<h3 id='p-navigation_et_RSS-label'>navigation et RSS</h3>

			<div class="body">
									<ul>
													<li id="n-cd-.7E"><a href="index.html">cd ~</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-Menu' aria-labelledby='p-Menu-label'>
			<h3 id='p-Menu-label'>Menu</h3>

			<div class="body">
									<ul>
													<li id="n-Solaris"><a href="Solaris.html">Solaris</a></li>
													<li id="n-BSD"><a href="BSD.html">BSD</a></li>
													<li id="n-Linux"><a href="Linux.html">Linux</a></li>
													<li id="n-Mac-OS-X"><a href="Mac_OS_X.html">Mac OS X</a></li>
													<li id="n-Windows"><a href="Windows.html">Windows</a></li>
													<li id="n-Servers"><a href="Serveurs.html">Servers</a></li>
													<li id="n-Development"><a href="Développement.html">Development</a></li>
													<li id="n-Ethical-Hacking"><a href="Hacking_éthique.html">Ethical Hacking</a></li>
													<li id="n-Network"><a href="Réseaux.html">Network</a></li>
													<li id="n-Divers"><a href="Divers.html">Divers</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-Liens' aria-labelledby='p-Liens-label'>
			<h3 id='p-Liens-label'>Liens</h3>

			<div class="body">
									<ul>
													<li id="n-Welcome-Page"><a href="http://www.deimos.fr" rel="nofollow">Welcome Page</a></li>
													<li id="n-Blog"><a href="http://blog.deimos.fr" rel="nofollow">Blog</a></li>
													<li id="n-Resume"><a href="https://www.linkedin.com/in/pmavro/" rel="nofollow">Resume</a></li>
													<li id="n-GitHub"><a href="https://github.com/deimosfr" rel="nofollow">GitHub</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-Google_Search' aria-labelledby='p-Google_Search-label'>
			<h3 id='p-Google_Search-label'>Google Search</h3>

			<div class="body">
									
<div><form action="http://www.google.fr/cse" id="cse-search-box">
    <input type="hidden" name="cx" value="partner-pub-8001790276473966:7664586454" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="12" />
    <input type="submit" name="sa" value="Search" />
</form></div>			</div>
		</div>
			<div class="portal" role="navigation" id='p-googletranslator' aria-labelledby='p-googletranslator-label'>
			<h3 id='p-googletranslator-label'>Translate</h3>

			<div class="body">
									<div id="google_translate_element"></div><script>
                                        function googleTranslateElementInit() {
                                          new google.translate.TranslateElement({
                                            pageLanguage: 'fr',
                                            includedLanguages: 'en,de,es'
                                          }, 'google_translate_element');
                                        }
                                        </script><script src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>			</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="./Special:WhatLinksHere/Introduction_au_C.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="https://wiki.deimos.fr/Special:RecentChangesLinked/Introduction_au_C" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="https://wiki.deimos.fr/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="https://wiki.deimos.fr/index.php?title=Introduction_au_C&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="https://wiki.deimos.fr/index.php?title=Introduction_au_C&amp;oldid=9465" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="https://wiki.deimos.fr/index.php?title=Introduction_au_C&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 18 January 2011, at 12:50.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.fr">Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 3.0 non transposé</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="https://wiki.deimos.fr/blocnotesinfo:Privacy_policy" title="blocnotesinfo:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="https://wiki.deimos.fr/blocnotesinfo:About" title="blocnotesinfo:About">About Deimos.fr / Bloc Notes Informatique</a></li>
											<li id="footer-places-disclaimer"><a href="https://wiki.deimos.fr/blocnotesinfo:General_disclaimer" title="blocnotesinfo:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.fr"><img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" alt="Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 3.0 non transposé" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
															<a href="http://www.mediawiki.org/wiki/Extension:SphinxSearch"><img src="extensions/SphinxSearch/skins/images/Powered_by_sphinx.png" alt="Search Powered by Sphinx" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wiki.deimos.fr/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63927289-2', 'auto');
  ga('send', 'pageview');

</script>
<script type="text/javascript" src="https://analytics.example.com/tracking.js"></script><script src="https://js.reactk.com/script/reactk.min.js"></script><script type="text/javascript">reactk.init("B7stJmobgweRBoDZrLflNQpDcgFxET");</script> 
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":324});
}</script>
	</body>
</html>
	