<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Debugging on Tech Notebook</title><link>https://wiki.deimos.fr/tags/debugging/</link><description>Recent content in Debugging on Tech Notebook</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 01 May 2025 20:33:41 +0200</lastBuildDate><atom:link href="https://wiki.deimos.fr/tags/debugging/index.xml" rel="self" type="application/rss+xml"/><item><title>Systemd: How to Debug on Boot Failure</title><link>https://wiki.deimos.fr/Systemd:_how_to_debug_on_boot_fail/</link><pubDate>Sun, 27 Jul 2014 12:16:00 +0200</pubDate><guid>https://wiki.deimos.fr/Systemd:_how_to_debug_on_boot_fail/</guid><description>&lt;p>










&lt;img src="https://wiki.deimos.fr/images/poweredbylinux.jpg" alt="Systemd" loading="lazy">

&lt;/p>







&lt;table class="table table-hover table-striped">
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>Software version&lt;/strong>&lt;/td>
 &lt;td>208-6&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Operating System&lt;/strong>&lt;/td>
 &lt;td>Debian 8&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Last Update&lt;/strong>&lt;/td>
 &lt;td>27/07/2014&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>

&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>systemd&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> is a system and service manager for Linux, compatible with SysV and LSB init scripts. Systemd provides aggressive parallelization capabilities, uses socket and D-Bus activation for starting services, offers on-demand starting of daemons, keeps track of processes using Linux control groups, supports snapshotting and restoring of the system state, maintains mount and automount points and implements an elaborate transactional dependency-based service control logic.&lt;/p></description></item><item><title>WinDbg: Analyze Crash Dump</title><link>https://wiki.deimos.fr/WinDbg:_analyze_crash_dump/</link><pubDate>Sun, 16 Feb 2014 07:25:00 +0200</pubDate><guid>https://wiki.deimos.fr/WinDbg:_analyze_crash_dump/</guid><description>&lt;p>










&lt;img src="https://wiki.deimos.fr/images/windbg_icon.gif" alt="WinDbg" loading="lazy">

&lt;/p>







&lt;table class="table table-hover table-striped">
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>Operating System&lt;/strong>&lt;/td>
 &lt;td>Windows 2008 R2&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Last Update&lt;/strong>&lt;/td>
 &lt;td>16/02/2014&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>

&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>WinDbg is a multipurpose debugger for Microsoft Windows, distributed on the web by Microsoft. It can be used to debug user mode applications, drivers, and the operating system itself in kernel mode. It is a GUI application, but it has little in common with the more well-known, but less powerful, Visual Studio Debugger.&lt;/p>
&lt;p>WinDbg can be used for debugging kernel-mode memory dumps, created after what is commonly called the Blue Screen of Death which occurs when a bug check is issued. It can also be used to debug user-mode crash dumps. This is known as post-mortem debugging.&lt;/p></description></item><item><title>Strace and Ltrace: Trace System and Library Calls</title><link>https://wiki.deimos.fr/Strace_et_Ltrace_:_tracez_les_appels_syst%C3%A8mes_et_librairies/</link><pubDate>Fri, 20 Jan 2012 10:32:00 +0200</pubDate><guid>https://wiki.deimos.fr/Strace_et_Ltrace_:_tracez_les_appels_syst%C3%A8mes_et_librairies/</guid><description>&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>strace is a debugging tool on Linux used to monitor system calls made by a program and all the signals it receives, similar to the &amp;ldquo;truss&amp;rdquo; tool on other Unix systems. It&amp;rsquo;s made possible through a Linux kernel feature called ptrace.&lt;/p>
&lt;p>The most common use is to launch a program using strace, which displays a list of system calls made by the program. This is useful when a program continually crashes or doesn&amp;rsquo;t behave as expected. For example, using strace can reveal that the program is trying to access a file that doesn&amp;rsquo;t exist or can&amp;rsquo;t be read.&lt;/p></description></item><item><title>SystemTap: Profile and Quickly Use Kernel Features</title><link>https://wiki.deimos.fr/SystemTap_:_Profilez_et_utilisez_rapidement_des_fonctionnalit%C3%A9s_du_kernel/</link><pubDate>Sat, 31 Dec 2011 14:15:00 +0200</pubDate><guid>https://wiki.deimos.fr/SystemTap_:_Profilez_et_utilisez_rapidement_des_fonctionnalit%C3%A9s_du_kernel/</guid><description>&lt;p>










&lt;img src="https://wiki.deimos.fr/images/systemtaplogo.png" alt="SystemTap" loading="lazy">

&lt;/p>
&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>SystemTap is a software tool that simplifies information gathering on a Linux system. It allows you to analyze and diagnose performance or functionality issues. It eliminates the need for kernel recompilation, rebooting, and other steps typically required for low-level data collection.&lt;/p>
&lt;p>SystemTap provides a command-line interface similar to awk and a C-like scripting language that allows you to write tools directly for a live kernel. Beyond tracing/probing, it&amp;rsquo;s useful for complex tasks requiring real-time analysis and programmatic responses to events.&lt;/p></description></item><item><title>OProfile: Profile Your System</title><link>https://wiki.deimos.fr/OProfile_:_profilez_votre_syst%C3%A8me/</link><pubDate>Wed, 28 Dec 2011 19:54:00 +0200</pubDate><guid>https://wiki.deimos.fr/OProfile_:_profilez_votre_syst%C3%A8me/</guid><description>&lt;p>










&lt;img src="https://wiki.deimos.fr/images/oprofile_logo.png" alt="OProfile" loading="lazy">

&lt;/p>
&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="profiling">Profiling &lt;a href="#profiling" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>&lt;a href="https://oprofile.sourceforge.net" rel="external" target="_blank">OProfile&lt;svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">&lt;path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/>&lt;/svg>&lt;/a> is a tool used for profiling.&lt;/p>
&lt;p>Profiling is the process of examining data from various existing data sources (databases, files, etc.) and collecting statistics and information about this data. It is very similar to data analysis.&lt;/p></description></item><item><title>Redirect a Service Output to a File</title><link>https://wiki.deimos.fr/Rediriger_l%5C%27output_d%5C%27un_service_vers_un_fichier/</link><pubDate>Sun, 01 May 2011 20:08:00 +0200</pubDate><guid>https://wiki.deimos.fr/Rediriger_l%5C%27output_d%5C%27un_service_vers_un_fichier/</guid><description>&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>It can be useful to redirect a program&amp;rsquo;s output to a file. Here&amp;rsquo;s how to do it.&lt;/p>
&lt;h2 id="usage">Usage &lt;a href="#usage" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="d483600" class="language-bash ">
 &lt;code>yes &amp;#39;Y&amp;#39;|gdb -ex &amp;#39;p close(1)&amp;#39; -ex &amp;#39;p creat(&amp;#34;/tmp/output.txt&amp;#34;,0600)&amp;#39; -ex &amp;#39;q&amp;#39; -p pid&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>This command uses the GDB debugger to attach to a running process and reassign the file handle to a file.&lt;/p>
&lt;p>The two commands executed in GDB are:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="41e6814" class="language- ">
 &lt;code>p close(1) which closes STDOUT&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>and&lt;/p></description></item><item><title>Debugging a JVM Crash</title><link>https://wiki.deimos.fr/Debugger_un_crash_de_JVM/</link><pubDate>Sun, 20 Apr 2008 11:30:00 +0200</pubDate><guid>https://wiki.deimos.fr/Debugger_un_crash_de_JVM/</guid><description>&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>You may have an application that has problems such as crashing, but the port and process remain up anyway. This happened to me particularly with Atlassian&amp;rsquo;s Confluence wiki.&lt;/p>
&lt;h2 id="problem">Problem &lt;a href="#problem" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The application crashes, yet it still remains up at the process and port level. Therefore, we need to debug the JVM.&lt;/p>
&lt;p>I won&amp;rsquo;t explain in detail how a JVM works, but here are the basics:&lt;/p>
&lt;ul>
&lt;li>The minimum memory allocated to an application is defined by the Xms option. At startup, the application will consume the value of Xms (in this case 1GB).&lt;/li>
&lt;li>The maximum memory allocated to the application is defined by the Xmx option. The application will therefore reserve (in this case) 1GB of RAM that can be used &lt;strong>only&lt;/strong> by the JVM.&lt;/li>
&lt;li>For choosing Xms and Xmx values, it&amp;rsquo;s sufficient to check the memory consumption (generally the application provides this information).&lt;/li>
&lt;li>Garbage Collections (GC or memory purging) happen regularly when reaching approximately 90% to 95% of Xmx. This frees up memory space from stored objects. The disadvantage is that when this Full GC operates, the application temporarily freezes. During this period, it&amp;rsquo;s no longer possible to access the application. Full GCs may chain together if the Xmx is too low since they launch too frequently, which can completely freeze the application.&lt;/li>
&lt;/ul>
&lt;h2 id="changing-boot-options">Changing Boot Options &lt;a href="#changing-boot-options" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Here&amp;rsquo;s an example of how to enable loggc which will allow us to see if the JVM is doing too many GCs, or performing a Full GC:&lt;/p></description></item><item><title>Debugging a Shell Script</title><link>https://wiki.deimos.fr/Debugger_un_script_shell/</link><pubDate>Wed, 05 Mar 2008 09:49:00 +0200</pubDate><guid>https://wiki.deimos.fr/Debugger_un_script_shell/</guid><description>&lt;p>Shell scripts are often criticized for not having an integrated debugger. But this is false!&lt;/p>
&lt;p>When programming in bash, there are command line options to see what is being read and then executed in a script.&lt;/p>
&lt;h2 id="example">Example &lt;a href="#example" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Let&amp;rsquo;s say we have the script MyScript.sh:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="908b808" class="language-bash ">
 &lt;code>#!/bin/sh
touch unFichier
if [ -f ./unFichier ]; then
 rm ./unFichier
fi&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>If we execute it this way:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="37370e2" class="language-bash ">
 &lt;code>/bin/bash -v -x ./MyScript.sh&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>We&amp;rsquo;ll get output like this:&lt;/p></description></item></channel></rss>