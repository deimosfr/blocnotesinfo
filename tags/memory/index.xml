<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memory on Tech Notebook</title><link>https://wiki.deimos.fr/tags/memory/</link><description>Recent content in Memory on Tech Notebook</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 01 May 2025 20:33:41 +0200</lastBuildDate><atom:link href="https://wiki.deimos.fr/tags/memory/index.xml" rel="self" type="application/rss+xml"/><item><title>Memory Caches</title><link>https://wiki.deimos.fr/Les_caches_m%C3%A9moire/</link><pubDate>Wed, 12 Sep 2012 16:58:00 +0200</pubDate><guid>https://wiki.deimos.fr/Les_caches_m%C3%A9moire/</guid><description>&lt;table class="table table-hover table-striped">
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>Software version&lt;/strong>&lt;/td>
 &lt;td>Kernel 2.6.32+&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Operating System&lt;/strong>&lt;/td>
 &lt;td>Red Hat 6.3&lt;br />Debian 7&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Website&lt;/strong>&lt;/td>
 &lt;td>&lt;a href="https://www.kernel.org" rel="external" target="_blank">Kernel Website&lt;svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">&lt;path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/>&lt;/svg>&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Last Update&lt;/strong>&lt;/td>
 &lt;td>12/09/2012&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>

&lt;h2 id="page-allocation">Page Allocation &lt;a href="#page-allocation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Delaying memory allocation when a process requests it is good for performance. Due to reference locality, most programs that request large memory allocations don&amp;rsquo;t allocate all of it at once. For program memory allocation, it will be done gradually to avoid using more than necessary.&lt;/p></description></item><item><title>Memory Addressing and Allocation</title><link>https://wiki.deimos.fr/L%27adressage_m%C3%A9moire_et_son_allocation/</link><pubDate>Tue, 11 Sep 2012 16:53:00 +0200</pubDate><guid>https://wiki.deimos.fr/L%27adressage_m%C3%A9moire_et_son_allocation/</guid><description>&lt;p>










&lt;img src="https://wiki.deimos.fr/images/poweredbylinux.jpg" alt="Linux" loading="lazy">

&lt;/p>







&lt;table class="table table-hover table-striped">
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>Software version&lt;/strong>&lt;/td>
 &lt;td>Kernel 2.6.32+&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Operating System&lt;/strong>&lt;/td>
 &lt;td>Red Hat 6.3&lt;br />Debian 7&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Website&lt;/strong>&lt;/td>
 &lt;td>&lt;a href="https://www.kernel.org" rel="external" target="_blank">Kernel Website&lt;svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">&lt;path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/>&lt;/svg>&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Last Update&lt;/strong>&lt;/td>
 &lt;td>11/09/2012&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>

&lt;h2 id="memory-addressing">Memory Addressing &lt;a href="#memory-addressing" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>For better efficiency, a computer&amp;rsquo;s memory is divided into blocks (chunks) called pages. Page size may vary depending on the processor architecture (32 or 64 bits). RAM is divided into page frames. One page frame can contain one page. When a process wants to access a memory address, a translation from the page to the page frame must be performed. If this information is not already in memory, the kernel must perform a search to manually load this page into the page frame.&lt;/p></description></item><item><title>Tmpfs: Mounting a RAM filesystem on Solaris</title><link>https://wiki.deimos.fr/Tmpfs_:_monter_un_filesystem_en_RAM_sous_Solaris/</link><pubDate>Sun, 19 Feb 2012 09:07:00 +0200</pubDate><guid>https://wiki.deimos.fr/Tmpfs_:_monter_un_filesystem_en_RAM_sous_Solaris/</guid><description>&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>TmpFS (Temporary File System) is the generic name given to any temporary Unix file system. Any file created in such a filesystem disappears when the system is shut down.&lt;/p>
&lt;p>The default implementation of tmpfs in Linux 2.6.x kernels is based on ramfs, which uses the caching mechanism to optimize memory management.
It is also available on Solaris 10.&lt;/p>
&lt;p>However, tmpfs additionally offers a memory size limit that is set at mount time and can be modified on-the-fly with the &amp;ldquo;remount&amp;rdquo; option for security purposes. Tmpfs also allows the system to use swap space when necessary, which provides an additional guarantee.&lt;/p></description></item><item><title>SWAP: Creating Dynamic Swap</title><link>https://wiki.deimos.fr/SWAP_:_Cr%C3%A9ation_de_swap_dynamique/</link><pubDate>Sat, 19 Sep 2009 21:47:00 +0200</pubDate><guid>https://wiki.deimos.fr/SWAP_:_Cr%C3%A9ation_de_swap_dynamique/</guid><description>&lt;h2 id="introduction">Introduction &lt;a href="#introduction" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Creating a swap partition is quite straightforward but extremely useful when you&amp;rsquo;re running out of RAM.&lt;/p>
&lt;h2 id="creating-swap">Creating Swap &lt;a href="#creating-swap" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="on-a-partition">On a Partition &lt;a href="#on-a-partition" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>Use fdisk on the target partition:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="ee700a7" class="language-bash ">
 &lt;code>fdisk /dev/hdc1&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>Then create a primary partition with the key combination &lt;strong>&amp;ldquo;n p 1&amp;rdquo;&lt;/strong>. Next, change the ID to indicate it&amp;rsquo;s a swap partition with &lt;strong>&amp;ldquo;t 82&amp;rdquo;&lt;/strong>.&lt;/p>
&lt;p>Save everything with the &amp;ldquo;w&amp;rdquo; key. To finish setting up our partition, we need to initialize it:&lt;/p></description></item><item><title>Java Memory Management</title><link>https://wiki.deimos.fr/gestion_de_la_memoire_en_java/</link><pubDate>Fri, 02 May 2008 15:36:00 +0200</pubDate><guid>https://wiki.deimos.fr/gestion_de_la_memoire_en_java/</guid><description>&lt;p>Here is documentation on memory management usage. It&amp;rsquo;s not up to date but it explains very well how a JVM works.&lt;/p>
&lt;p>&lt;a href="https://wiki.deimos.fr/pdf/memoire-java.pdf">Documentation on Java memory management&lt;/a>&lt;/p></description></item><item><title>Windows XP: Memory Overflow Problems</title><link>https://wiki.deimos.fr/Windows_XP_:_Probl%C3%A8mes_lors_d%27un_d%C3%A9passement_m%C3%A9moire/</link><pubDate>Tue, 21 Aug 2007 07:15:00 +0200</pubDate><guid>https://wiki.deimos.fr/Windows_XP_:_Probl%C3%A8mes_lors_d%27un_d%C3%A9passement_m%C3%A9moire/</guid><description>&lt;h2 id="memory-overflow-problems">Memory Overflow Problems &lt;a href="#memory-overflow-problems" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>If you encounter a memory overflow problem that prevents you from launching any application, you need to use &amp;ldquo;regedit&amp;rdquo; and edit this registry path:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="2260bdc" class="language- ">
 &lt;code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SubSystems&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>The &amp;ldquo;Windows&amp;rdquo; value contains a long line. You&amp;rsquo;ll find a part that looks like this:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="af93deb" class="language- ">
 &lt;code>SharedSection=xxxx,yyyy,zzzz&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>Edit the yyyy section and increase it as shown in this example:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="452329f" class="language- ">
 &lt;code>Windows SharedSection=1024,3072,512 &lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>Modified line:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="8a1884d" class="language- ">
 &lt;code>Windows SharedSection=1024,8192,512&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>Here, we&amp;rsquo;re increasing the GDI memory (the application that manages windows) from 3MB to 8MB.&lt;/p></description></item><item><title>Arbitrary Code Injection and Execution in Another Process Memory Space</title><link>https://wiki.deimos.fr/Injection_et_ex%C3%A9cution_de_code_arbitraire_dans_l%5C%27espace_m%C3%A9moire_d%5C%27un_autre_processus/</link><pubDate>Fri, 03 Aug 2007 16:44:00 +0200</pubDate><guid>https://wiki.deimos.fr/Injection_et_ex%C3%A9cution_de_code_arbitraire_dans_l%5C%27espace_m%C3%A9moire_d%5C%27un_autre_processus/</guid><description>&lt;p>&lt;a href="https://wiki.deimos.fr/pdf/injection_de_code.pdf">Arbitrary Code Injection and Execution in Another Process Memory Space&lt;/a>&lt;/p></description></item><item><title>How to Check the Page Size of Your Machine</title><link>https://wiki.deimos.fr/Connaitre_le_page_size_de_sa_machine/</link><pubDate>Wed, 09 May 2007 13:11:00 +0200</pubDate><guid>https://wiki.deimos.fr/Connaitre_le_page_size_de_sa_machine/</guid><description>&lt;h2 id="determining-the-page-size">Determining the Page Size &lt;a href="#determining-the-page-size" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Most operating systems allow programs to determine what the page size is so that they can allocate memory more efficiently.&lt;/p>
&lt;h3 id="unix-and-posix-based-operating-systems">UNIX and POSIX-based Operating Systems &lt;a href="#unix-and-posix-based-operating-systems" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>UNIX and POSIX-based systems use the C function sysconf().&lt;/p>
&lt;p>Edit a test.c file and paste it:&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="fc4196b" class="language-c ">
 &lt;code>#include &amp;lt;stdio.h&amp;gt; // printf(3)
#include &amp;lt;unistd.h&amp;gt; // sysconf(3)

int
main(void)
{
 printf(&amp;#34;The page size for this system is %ld bytes\n&amp;#34;, sysconf(_SC_PAGESIZE)); //_SC_PAGE_SIZE is OK too.
 return 0;
}&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>Then compile it with gcc:&lt;/p></description></item></channel></rss>