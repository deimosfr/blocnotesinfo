<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>Optimiser les performances des disques dur sur Linux - Deimos.fr / Bloc Notes Informatique</title>
<meta name="generator" content="MediaWiki 1.25.5" />
<link rel="shortcut icon" href="https://wiki.deimos.fr/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Deimos.fr / Bloc Notes Informatique (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.deimos.fr/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="Optimiser_les_performances_des_disques_dur_sur_Linux.html" />
<link rel="copyright" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.fr" />
<link rel="alternate" type="application/atom+xml" title="Deimos.fr / Bloc Notes Informatique Atom feed" href="https://wiki.deimos.fr/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="load.php%3Fdebug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint,shared|mediawiki.sectionAnchor|mediawiki.skinning.interface|mediawiki.ui.button|skins.vector.styles&amp;only=styles&amp;skin=vector&amp;*.css" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="load.php%3Fdebug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*.css" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: blocnotesinfo-wiki_:resourceloader:filter:minify-css:7:6f8c0c45eefd74c7bbe9478b32df38c0 */</style>
<script src="load.php%3Fdebug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Optimiser_les_performances_des_disques_dur_sur_Linux","wgTitle":"Optimiser les performances des disques dur sur Linux","wgCurRevisionId":13101,"wgRevisionId":13101,"wgArticleId":3438,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Optimiser_les_performances_des_disques_dur_sur_Linux","wgRelevantArticleId":3438,"wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"publish":false}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: blocnotesinfo-wiki_:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-bash {line-height: normal;}
.source-bash li, .source-bash pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for bash
 * CSS class: source-bash, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.bash.source-bash .de1, .bash.source-bash .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.bash.source-bash  {font-family:monospace;}
.bash.source-bash .imp {font-weight: bold; color: red;}
.bash.source-bash li, .bash.source-bash .li1 {font-weight: normal; vertical-align:top;}
.bash.source-bash .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.bash.source-bash .li2 {font-weight: bold; vertical-align:top;}
.bash.source-bash .kw1 {color: #000000; font-weight: bold;}
.bash.source-bash .kw2 {color: #c20cb9; font-weight: bold;}
.bash.source-bash .kw3 {color: #7a0874; font-weight: bold;}
.bash.source-bash .co0 {color: #666666; font-style: italic;}
.bash.source-bash .co1 {color: #800000;}
.bash.source-bash .co2 {color: #cc0000; font-style: italic;}
.bash.source-bash .co3 {color: #000000; font-weight: bold;}
.bash.source-bash .co4 {color: #666666;}
.bash.source-bash .es1 {color: #000099; font-weight: bold;}
.bash.source-bash .es2 {color: #007800;}
.bash.source-bash .es3 {color: #007800;}
.bash.source-bash .es4 {color: #007800;}
.bash.source-bash .es5 {color: #780078;}
.bash.source-bash .es_h {color: #000099; font-weight: bold;}
.bash.source-bash .br0 {color: #7a0874; font-weight: bold;}
.bash.source-bash .sy0 {color: #000000; font-weight: bold;}
.bash.source-bash .st0 {color: #ff0000;}
.bash.source-bash .st_h {color: #ff0000;}
.bash.source-bash .nu0 {color: #000000;}
.bash.source-bash .re0 {color: #007800;}
.bash.source-bash .re1 {color: #007800;}
.bash.source-bash .re2 {color: #007800;}
.bash.source-bash .re4 {color: #007800;}
.bash.source-bash .re5 {color: #660033;}
.bash.source-bash .ln-xtra, .bash.source-bash li.ln-xtra, .bash.source-bash div.ln-xtra {background-color: #ffc;}
.bash.source-bash span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Optimiser_les_performances_des_disques_dur_sur_Linux skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Optimiser les performances des disques dur sur Linux</span></h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From Deimos.fr / Bloc Notes Informatique</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#mw-navigation">navigation</a>, 					<a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Quels_sont_les_facteurs_de_lenteur_.3F"><span class="tocnumber">2</span> <span class="toctext">Quels sont les facteurs de lenteur&#160;?</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Alignement_des_partitions"><span class="tocnumber">3</span> <span class="toctext">Alignement des partitions</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Diff.C3.A9rences_entre_disques_.C3.A9lectrom.C3.A9canique_et_SSD"><span class="tocnumber">4</span> <span class="toctext">Différences entre disques électromécanique et SSD</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Les_diff.C3.A9rents_bus_de_donn.C3.A9es"><span class="tocnumber">5</span> <span class="toctext">Les différents bus de données</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Caches_et_taux_de_transfert"><span class="tocnumber">6</span> <span class="toctext">Caches et taux de transfert</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Requ.C3.AAtes_IO_et_caches"><span class="tocnumber">7</span> <span class="toctext">Requêtes IO et caches</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Les_acc.C3.A8s_en_lecture_s.C3.A9quentiel"><span class="tocnumber">8</span> <span class="toctext">Les accès en lecture séquentiel</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Les_scheduleurs"><span class="tocnumber">9</span> <span class="toctext">Les scheduleurs</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#cfq"><span class="tocnumber">9.1</span> <span class="toctext">cfq</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#deadline"><span class="tocnumber">9.2</span> <span class="toctext">deadline</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#anticipatory"><span class="tocnumber">9.3</span> <span class="toctext">anticipatory</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#noop"><span class="tocnumber">9.4</span> <span class="toctext">noop</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Optimisations_pour_les_SSDs"><span class="tocnumber">10</span> <span class="toctext">Optimisations pour les SSDs</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Alignement"><span class="tocnumber">10.1</span> <span class="toctext">Alignement</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#TRIM"><span class="tocnumber">10.2</span> <span class="toctext">TRIM</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Sur_LVM"><span class="tocnumber">10.2.1</span> <span class="toctext">Sur LVM</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#noatime"><span class="tocnumber">10.3</span> <span class="toctext">noatime</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Le_scheduleur"><span class="tocnumber">10.4</span> <span class="toctext">Le scheduleur</span></a>
<ul>
<li class="toclevel-3 tocsection-20"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#D.C3.A9tection_de_SSD"><span class="tocnumber">10.4.1</span> <span class="toctext">Détection de SSD</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Limiter_l.27.C3.A9criture"><span class="tocnumber">10.5</span> <span class="toctext">Limiter l'écriture</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#References"><span class="tocnumber">11</span> <span class="toctext">References</span></a></li>
</ul>
</div>

<table class="config_array" align="right" style="width:20em; font-size:90%; text-align:left; border: 1px #d0e7ff solid; margin-left:10px;">
   <tr>
      <td class="config_subarray" colspan="2" style="text-align:center;"><a href="./File:Poweredbylinux.jpg.html" class="image" title="Linux"><img alt="Linux" src="images/2/2f/Poweredbylinux.jpg" width="100" height="150" /></a></td>
   </tr><tr><td colspan="2" style="text-align:center;"><hr class="gradient" /></td></tr><tr>
      <th>Software version</th>
      <td>Kernel 2.6.32+</td>
   </tr><tr>
      <th>Operating System</th>
      <td>Red Hat 6.3<br />Debian 7</td>
   </tr><tr>
      <th>Website</th>
      <td><a rel="nofollow" class="external text" href="http://www.kernel.org">Kernel Website</a></td>
   </tr><tr>
      <th>Last Update</th>
      <td>02/01/2014</td>
   </tr><tr>
      <th>Others</th>
      <td></td>
   </tr>
</table>
<h1><span class="mw-headline" id="Introduction"><span class="mw-headline-number">1</span> Introduction</span></h1>
<p>Les disques dur physiques sont aujourd'hui ce qu'il y a de plus lent dans nos machines. Que ce soit les disques dur physique à plateaux ou bien même les SSD&#160;! Mais il y a moyen d'optimiser selon les besoins des performances de ceux ci. Nous allons voir ici plusieurs aspects qui devrait vous aider à comprendre pourquoi il peut y avoir des saturations, comment les éviter et les solutions pour faire des benchmarks.
</p>
<h1><span class="mw-headline" id="Quels_sont_les_facteurs_de_lenteur_.3F"><span class="mw-headline-number">2</span> Quels sont les facteurs de lenteur&#160;?</span></h1>
<p>Il existe plusieurs facteurs qui peuvent être à la cause de lenteurs sur vos disques (IO disques). Si ce sont des disques électromécanique, ils seront plus lent que des SSD et auront des contraintes supplémentaire&#160;:
</p>
<ul><li> La vitesse de rotation des disques</li>
<li> La vitesse de lecture par seconde sera meilleure sur la fin des disques (la partie la plus éloignée du centre)</li>
<li> Les données qui ne sont pas alignées sur le disque</li>
<li> Les petites partitions présentes sur la fin du disque</li>
<li> La vitesse du bus sur lesquels les disques sont</li>
<li> Le seek time, qui correspond au temps de déplacement de la tête de lecture</li></ul>
<h1><span class="mw-headline" id="Alignement_des_partitions"><span class="mw-headline-number">3</span> Alignement des partitions</span></h1>
<p>L'alignement consiste à faire correspondre les blocs logiques des partitions avec les blocs physiques afin de limiter les opérations de lecture/écriture et ainsi ne pas entraver les performances.
</p><p>Les SSD actuels travaillent en interne sur des blocs de 1 ou 2 Mio, c'est à dire respectivement 1 048 576 ou 2 097 152 octets. Considérant qu'un secteur stocke 512 octets, il faudra ainsi 2 048 secteurs pour stocker 1 048 576 octets.
Si, traditionnellement, les systèmes d'exploitation faisaient démarrer la première partition au 63ème secteur, les dernières versions prennent en compte les contraintes des SSD.<br />
Ainsi <a href="./Parted_:_résoudre_les_problèmes_de_partionnnement_sur_gros_filesystems.html#Partitionnement" title="Parted : résoudre les problèmes de partionnnement sur gros filesystems">Parted</a> peut aligner automatiquement les début des partitions sur des multiples de 2 048 secteurs.
</p><p>Pour vous assurer du bon alignement des partitions, entrez la commande suivante avec les privilèges d'administration et vérifiez que le nombre de secteurs au début de chacune de vos partitions est bien un multiple de 2 048. Voici la commande pour une table de partition de type MSDOS&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> fdisk</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">fdisk -lu /dev/sdX</pre></div></div>
</td></tr></table><br />
<p>Dans le cas ou vous avez une table de partition de type GPT&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> parted</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">parted -l /dev/sdX</pre></div></div>
</td></tr></table><br />
<h1><span class="mw-headline" id="Diff.C3.A9rences_entre_disques_.C3.A9lectrom.C3.A9canique_et_SSD"><span class="mw-headline-number">4</span> Différences entre disques électromécanique et SSD</span></h1>
<p>Maintenant, pour mieux comprendre la différence entre la fin du disque (celui le plus proche du centre) et le début disque (le plus éloigné du centre), laissez moi vous montrer un test entre une clef USB (linéaire, équivalent à un SSD) et un disque dur (non linéaire). Pour cela nous allons utiliser un outil de benchmark appelé bonnie++. Nous l'installons donc&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> aptitude</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">aptitude install bonnie++</pre></div></div>
</td></tr></table><br />
<p>Et nous allons lancer une capture sur les 2 disques avec l'utilitaire zcav qui nous permet de tester le débit en mode raw&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> zcav</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="bash source-bash"><pre class="de1"><span class="kw1">for</span> i <span class="kw1">in</span> sdc sdd&#160;; <span class="kw1">do</span>
    zcav <span class="re5">-c1</span> <span class="sy0">/</span>dev<span class="sy0">/</span><span class="re1">$i</span> <span class="sy0">&gt;&gt;</span> ~<span class="sy0">/</span><span class="re1">$i</span>.zcav
<span class="kw1">done</span></pre></div></div>
</td></tr></table><br />
<p>L'option -c permet de dire le nombre de fois qu'il faut lire le disque entièrement.
</p><p>Puis nous allons générer un graphique des données avec Gnulpot&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> gnuplot</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&gt; gnuplot
set term png crop
set output '~/zcav_steppings.png'
set xlabel 'Blocks'
set xrange [0:]
set ylabel 'Disk throughput (MiB/s)'
set yrange [0:]
set border 3 
set xtics nomirror
set ytics nomirror
set title 'Zoned Constant Angular Velocity (ZCAV) steppings'
set key below box
plot '/home/pmavro/sdc.zcav' u 1:2 t '160 GiB Hard Drive' with lines, \
'/home/pmavro/sdd.zcav' u 1:2 t '64 GiB USB key' with lines</pre></div></div>
</td></tr></table><br />
<p>Pour rappel, j'ai fais un <a href="./Gnuplot_:_grapher_des_données_facilement.html" title="Gnuplot : grapher des données facilement">article sur Gnuplot</a>. Voici le résultat&#160;:
</p><p><a href="./File:Zcav_steppings.png.html" class="image"><img alt="Zcav steppings.png" src="images/1/14/Zcav_steppings.png" width="614" height="455" /></a>
</p><p>On voit très clairement que le disque dur se comporte très bien au début et souffre sur l'intérieur. La vitesse est quasiment 2 fois plus importante à l'extérieur à qu'à l'intérieur et cela s'explique par le bras oscillant qui lit plus de données sur une même période de temps à l'extérieur.
</p>
<h1><span class="mw-headline" id="Les_diff.C3.A9rents_bus_de_donn.C3.A9es"><span class="mw-headline-number">5</span> Les différents bus de données</span></h1>
<p>Il existe différents types de bus&#160;:
</p>
<ul><li> PCI</li>
<li> PCI-X</li>
<li> PCIe</li>
<li> AGP</li>
<li> ...</li></ul>
<p><b>Aujourd'hui c'est le PCI-X qui est le plus rapide</b>. Si vous avez des cartes RAID, vous pouvez vérifiez la vitesse de l'horloge, afin de s'assurer qu'elle tourne bien à son maximum pour délivrer autant de débit que possible. Vous pouvez trouver sur wikipedia toutes les informations nécessaires pour ces bus. L'important est de vérifier&#160;:
</p>
<ul><li> La taille du bus&#160;: 32/64 bits</li>
<li> La vitesse de l'horloge</li></ul>
<p>Voici un petit récapitulatif approximatif (varie avec les avancées technologiques)&#160;:
</p>
<table class="wikitable sortable" border="0">
<tr>
<th>Objet
</th>
<th>Latence
</th>
<th>Débit
</th></tr>
<tr>
<td align="center">Disque 10krpm
</td>
<td align="left">3ms
</td>
<td align="left">50Mo/s
</td></tr>
<tr>
<td align="center">Accès au swap
</td>
<td align="left">8ms
</td>
<td align="left">50Mo/s
</td></tr>
<tr>
<td align="center">Disque SSD
</td>
<td align="left">0.5ms
</td>
<td align="left">100Mo/s
</td></tr>
<tr>
<td align="center">Ethernet gigabit
</td>
<td align="left">1ms
</td>
<td align="left">133Mo/s
</td></tr>
<tr>
<td align="center">Interface pci
</td>
<td align="left">0.1us
</td>
<td align="left">133Mo/s
</td></tr>
<tr>
<td align="center">malloc/mmap
</td>
<td align="left">0.1us
</td>
<td align="left">
</td></tr>
<tr>
<td align="center">fork
</td>
<td align="left">0.1ms
</td>
<td align="left">
</td></tr>
<tr>
<td align="center">gettimeofday
</td>
<td align="left">1us
</td>
<td align="left">
</td></tr>
<tr>
<td align="center">context switch
</td>
<td align="left">3us
</td>
<td align="left">
</td></tr>
<tr>
<td align="center">RAM
</td>
<td align="left">80ns
</td>
<td align="left">8Go/s
</td></tr>
<tr>
<td align="center">Interface pci-express 16x
</td>
<td align="left">10ns
</td>
<td align="left">8Go/s
</td></tr>
<tr>
<td align="center">Cache L2
</td>
<td align="left">5ns
</td>
<td align="left">
</td></tr>
<tr>
<td align="center">Cache L1
</td>
<td align="left">1ns
</td>
<td align="left">
</td></tr>
<tr>
<td align="center">Cache L1
</td>
<td align="left">0.3ns
</td>
<td align="left">40Go/s
</td></tr></table>
<p>Il existe également les bus de type SCSI. Ceux là sont un peu particulier, mais <b>il faut faire attention à ne pas mixer différentes vitesses d'horloge sur le même bus</b>, la taille des bus, les terminaisons passives/actives...<br />
Vous pouvez utiliser la commande sginfo pour récupérer tous les paramètres scsi de vos devices&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> </font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">aptitude install sg-utils
sginfo -a /dev/sda</pre></div></div>
</td></tr></table><br />
<h1><span class="mw-headline" id="Caches_et_taux_de_transfert"><span class="mw-headline-number">6</span> Caches et taux de transfert</span></h1>
<p>Les contrôleurs de disque récents ont des caches intégrés pour accélérer les accès en lecture et écriture. Par défaut, beaucoup de constructeurs désactivent le cache en écriture pour éviter toute corruption de données. Cependant, il est possible de configurer ce cache pour accélérer grandement les accès. De plus, lorsque ces contrôleurs embarquent avec une batterie, les cartes sont capables de garder pendant quelques heures à quelques jours les données. Une fois la machine allumée, la carte se chargera d'écrire les données sur le ou les disques.
</p><p>Pour calculer le taux de transfert d'un disque en bytes/secondes&#160;:
</p>
<pre>taux = (secteurs par pistes * rpm * 512) / 60
</pre>
<p>Pour les disques utilisant les ZCAV, il faut remplacer les secteurs par pistes par la moyenne de bytes par pistes&#160;:
</p>
<pre>vitesse = ((moyenne de secteurs par pistes * 512 * rpm) /60) / 1000000
</pre>
<h1><span class="mw-headline" id="Requ.C3.AAtes_IO_et_caches"><span class="mw-headline-number">7</span> Requêtes IO et caches</span></h1>
<p><a href="./File:Blockio_cache.gif.html" class="image"><img alt="Blockio cache.gif" src="images/d/dc/Blockio_cache.gif" width="500" height="522" /></a>
</p><p>Les requêtes IO de haut niveau comme les lecture/écriture faites par la couche Linux Virtual Filesystem doit être transformée en requêtes de block device. Le kernel procède alors a la mise en queue de chaque block device. Chaque block physique effectue sa propre demande de mise en queue. Les requêtes mises en queue sont des "Requests Descriptor". Elles décrivent les structures de données dont le kernel a besoin pour s'occuper des requêtes IO. Une "request descriptor" peut pointer vers un transfert IO qui pointera à son tour vers plusieurs blocks disques.
</p><p>Lorsqu'une demande d'IO sur un device est émise, une requête spéciale de structure est mise en queue dans la "Request Queue" pour le device en question. La structure de la requête contient des pointeurs désignant les secteurs sur le disque ou le "Buffer Cache (Page Cache)". Si la demande de requête est&#160;:
</p>
<ul><li> pour lire des données, le transfert se fera du disque vers la mémoire.</li>
<li> pour l'écriture de données, le transfert se fera de la mémoire vers le disque.</li></ul>
<p>L'ordonnancement des requêtes IO est un effort commun. Un drivers de haut niveau place une requête IO dans la request queue. Cette requête est envoyée au scheduler qui va utiliser un algorithme pour la traiter. Pour éviter tout effet d'étranglement, la requête ne sera pas immédiatement traitée, mais passée en mode bloquée ou connectée. Une fois qu'un certain nombre de requêtes sera atteint, la queue sera déconnectée et un driver de bas niveau se chargera des transferts de requêtes IO pour déplacer le blocks (disque) et pages (mémoire).
</p><p>L'unité utilisé pour le transfert d'IO est une page. Chaque page transférée depuis le disque correspond à une page en mémoire. Vous pouvez connaitre la taille des pages cache et buffer cache comme ceci&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> cat</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&gt; grep -ie '^cache' -ie '^buffer' /proc/meminfo
Buffers:          233184 kB
Cached:          2035636 kB</pre></div></div>
</td></tr></table><br />
<ul><li> Buffers&#160;: utilisé pour le stockage des metadatas du filesystem</li>
<li> Cached&#160;: utilisé pour cacher des fichiers de donnée</li></ul>
<p>En User mode, les programmes n'ont pas accès au contenu des buffers directement. Les buffers sont gérées par le kernel dans le "kernel space". Le kernel doit copier les données de ces buffers, dans l'espace user mode du processus qui a fait la demande de requête de fichier/inode représenté par des blocks cache ou pages mémoire.
</p>
<h1><span class="mw-headline" id="Les_acc.C3.A8s_en_lecture_s.C3.A9quentiel"><span class="mw-headline-number">8</span> Les accès en lecture séquentiel</span></h1>
<table width="100%" class="notes_array">
<tr>
<td class="notes_subarray"> <font size="-1"><a href="./File:Notes_file.png.html" class="image" title="Notes"><img alt="Notes" src="images/2/20/Notes_file.png" width="31" height="32" /></a> Notes</font>
</td></tr>
<tr>
<td>L'utilisation de la technologie read-ahead (lecture anticipée) n'a de sens que pour les applications qui lisent séquentiellement les données&#160;! Aucuns intérêts pour les accès aléatoire.
</td></tr></table><br />
<p>Lorsque vous faites des accès disques, le kernel essaye de lire séquentiellement les données sur le disque. La lecture anticipée (Read ahead), permet de lire plus de block que ce qui est demandé pour anticiper la demande et stocker ces données en cache. Car lorsqu'un block est lu, il est plus que très fréquent de devoir lire le bloc d'après, c'est pourquoi il peut être intéressant de tuner le read-ahead. Les avantages de cette méthode sont que&#160;:
</p>
<ul><li> Le kernel est capable de répondre plus rapidement à la demande</li>
<li> La charge du contrôleur de disques est moins chargé</li>
<li> Les temps de réponse sont grandement améliorés</li></ul>
<table width="100%" class="notes_array">
<tr>
<td class="notes_subarray"> <font size="-1"><a href="./File:Notes_file.png.html" class="image" title="Notes"><img alt="Notes" src="images/2/20/Notes_file.png" width="31" height="32" /></a> Notes</font>
</td></tr>
<tr>
<td>L'algorithme est conçu pour s'arrêter de lui même s'il détecte trop d'accès aléatoire pour ne pas casser les performances. N'ayez donc pas peur de tester cette fonctionnalité.
</td></tr></table><br />
<p>L'algorithme read-ahead est gérer par 2 valeurs&#160;:
</p>
<ul><li> La fenêtre courante&#160;: elle contrôle le nombre de données que le kernel va devoir traiter lorsqu'il fera des accès IO.</li>
<li> La fenetre ahead</li></ul>
<p><a href="./File:Disks_read_ahead.jpg.html" class="image"><img alt="Disks read ahead.jpg" src="images/2/20/Disks_read_ahead.jpg" width="1171" height="280" /></a>
</p><p>Lorsqu'une application fait une demande d'accès de pages en lecture dans le cache buffer (qui font partie de la fenêtre courante), les IO se font sur la fenêtre ahead&#160;! Par contre, quant l'application a fini sa lecture sur la fenêtre courante, la fenêtre ahead devient la nouvelle fenêtre courante et une nouvelle ahead est créer.<br />
<b>Si l'accès à une page se fait dans la fenêtre courante, la taille de la nouvelle fenêtre ahead sera alors augmentée de 2 pages. Si le débit de lecture ahead est faible, la taille de la fenêtre ahead sera réduite petit à petit.</b>
</p><p>Pour connaitre la taille des read ahead en secteurs (1 secteur = 512 Bytes)&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> blockdev</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&gt; blockdev --getra /dev/sda         
256</pre></div></div>
</td></tr></table><br />
<p>Ou bien en kilobyte&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> cat</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&gt; cat /sys/block/sda/queue/read_ahead_kb 
128</pre></div></div>
</td></tr></table><br />
<p>Si vous souhaitez bencher pour voir les meilleurs performances que vous pouvez atteindre avec vos disques&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> </font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&gt; DEV=&quot;sda&quot;&#160;; for V in 4 8 16 32 64 128 256 512 1024 2048 4096 8192; do echo $V; echo $V &gt; /sys/block/$DEV/queue/read_ahead_kb &amp;&amp; hdparm -t /dev/$DEV | grep &quot;Timing&quot;; done
4
 Timing buffered disk reads: 120 MB in  3.03 seconds =  39.58 MB/sec
8
 Timing buffered disk reads: 194 MB in  3.02 seconds =  64.15 MB/sec
16
 Timing buffered disk reads: 268 MB in  3.02 seconds =  88.73 MB/sec
32
 Timing buffered disk reads: 268 MB in  3.00 seconds =  89.25 MB/sec
64
 Timing buffered disk reads: 272 MB in  3.01 seconds =  90.38 MB/sec
128
 Timing buffered disk reads: 272 MB in  3.01 seconds =  90.46 MB/sec
256
 Timing buffered disk reads: 272 MB in  3.01 seconds =  90.24 MB/sec
512
 Timing buffered disk reads: 272 MB in  3.02 seconds =  90.18 MB/sec
1024
 Timing buffered disk reads: 270 MB in  3.00 seconds =  89.93 MB/sec
<span class="xtra ln-xtra">2048</span><span class="xtra ln-xtra"> Timing buffered disk reads: 272 MB in  3.00 seconds =  90.58 MB/sec</span>4096
 Timing buffered disk reads: 272 MB in  3.01 seconds =  90.33 MB/sec
8192
 Timing buffered disk reads: 270 MB in  3.00 seconds =  89.99 MB/sec</pre></div></div>
</td></tr></table><br />
<p>Il faut cependant prendre ces informations avec des pincettes puisqu'il faudrait les tester avec l'applicatif que vous voulez faire tourner sur ce disque pour obtenir un résultat vraiment satisfaisant. Ecrasez donc la valeur dans le /sys pour la changer. Insérez là dans /etc/rc.local pour la rendre persistante.
</p>
<table width="100%" class="notes_array">
<tr>
<td class="notes_subarray"> <font size="-1"><a href="./File:Notes_file.png.html" class="image" title="Notes"><img alt="Notes" src="images/2/20/Notes_file.png" width="31" height="32" /></a> Notes</font>
</td></tr>
<tr>
<td>La fenêtre read ahead initiale est égale à la moitié de celle paramétrée. Celle paramétrée correspond à la taille maximale de la fenêtre read ahead&#160;!
</td></tr></table><br />
<p>Vous pouvez obtenir un rapport comme ceci&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> blockdev</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&gt; blockdev --report /dev/sda         
RO    RA   SSZ   BSZ   StartSec            Size   Device
rw   256   512  1024          0    250000000000   /dev/sda</pre></div></div>
</td></tr></table><br />
<h1><span class="mw-headline" id="Les_scheduleurs"><span class="mw-headline-number">9</span> Les scheduleurs</span></h1>
<p>Lorsque que le kernel reçoit des demandes d'IO multiples en simultané, il doit les gérer pour éviter des conflits. La meilleure solution (au point de vue performances) d'accès au disque est la séquentialité des données adressées en block logique. De plus, les demandes d'IO sont priorisé par rapport à leur taille. Plus elles sont petites, plus elles vont être placées en haut de la queue, puisque le disque arrivera rapidement à délivrer ce type de données bien plus rapidement que pour des grosses.
</p><p>Afin d'éviter les goulets d'étranglement, le kernel s'assure que tous les process récupèrent tous des IO. C'est au rôle du scheduleur de s'assurer que les IO en bas de la queue soient processées et non toujours remis à plus tard.<br />
Lorsque l'on ajoute une entrée dans la queue, le kernel va d'abord tenter d'élargir la queue en cours et insérer la nouvelle requête dedans. Si ce n'est pas possible, la nouvelle requête sera assignée à une autre queue qui utilise un algorithme "elevator".
</p><p>Pour déterminer quel est l'IO scheduleur (algo elevator)&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> grep</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&gt; grep CONFIG_DEFAULT_IOSCHED /boot/config-`uname -r`
CONFIG_DEFAULT_IOSCHED=&quot;cfq&quot;</pre></div></div>
</td></tr></table><br />
<p>Voici les scheduleurs que vous pouvez trouver&#160;:
</p>
<ul><li> deadline&#160;: moins d'efficacité, mais moins de temps de réponse</li>
<li> anticipatory&#160;: des temps d'attente plus long, mais une meilleure efficacité</li>
<li> noop&#160;: le plus simple, il est fait pour économiser le CPU</li>
<li> cfq&#160;: essaye d'être le plus homogène possible en tous points</li></ul>
<p>Pour plus d'informations officielles&#160;: <a rel="nofollow" class="external free" href="http://www.kernel.org/doc/Documentation/block/">http://www.kernel.org/doc/Documentation/block/</a>
</p><p>Pour connaitre le scheduleur actuel utilisé&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> cat</font>
</td></tr>
<tr>
<td>
<pre>&gt; cat /sys/block/sda/queue/scheduler 
noop deadline <b>[cfq] </b>
</pre>
</td></tr></table><br />
<p>C'est donc l'algorithme entre crochet qui est utilisé. Pour changer de scheduleur&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> echo</font>
</td></tr>
<tr>
<td>
<pre>&gt; echo noop &gt; /sys/block/sda/queue/scheduler 
<b>[noop]</b> deadline cfq
</pre>
</td></tr></table><br />
<p>N'oubliez pas de mettre cette ligne dans /etc.rc.local si vous voulez du persistant.
</p>
<table width="100%" class="warning_array">
<tr>
<td class="warning_subarray"> <font size="-1"><a href="./File:Warning_file.png.html" class="image" title="Warning"><img alt="Warning" src="images/0/09/Warning_file.png" width="39" height="32" /></a> <b>WARNING</b></font>
</td></tr>
<tr>
<td>Ne faites pas ce qui suit sur une machine en production ou vous risquez d'avoir pendant quelques secondes de gros ralentissements
</td></tr></table><br />
<p>Pour écrire toutes les données en cache sur le disque, vider ces derniers et s'assurer de l'utilisation du dernier algorithme choisi&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> </font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">sync
sysctl -w vm.drop_caches=3</pre></div></div>
</td></tr></table><br />
<h2><span class="mw-headline" id="cfq"><span class="mw-headline-number">9.1</span> cfq</span></h2>
<p>C'est le scheduleur par défaut sur Linux, qui veut dire&#160;: Completly Fair Queuing. Ce scheduleur garde 64 queues de requêtes, les IO sont adressées via l'algorithme Round Robin à ces queues. Les requêtes adressées sont utilisées pour limiter au maximum des déplacements des têtes de lecture et donc gagner en vitesse.
</p><p>Les options possible sont&#160;:
</p>
<ul><li> quantum&#160;: le nombre total de requêtes placées sur la queue de dispatch par cycle</li>
<li> queued&#160;: le nombre maximum de requêtes autorisées par queue</li></ul>
<p>Pour tuner un peu l'élévator CFQ, il nous faut ce package installé pour avoir la commande ionice&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> aptitude</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">aptitude install util-linux</pre></div></div>
</td></tr></table><br />
<p>ionice permet de changer la priorité en lecture/écriture sur un process. Voici un exemple&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> ionice</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">ionice -p1000 -c2 -n7</pre></div></div>
</td></tr></table><br />
<ul><li> -p1&#160;: active la demande sur le PID 1000</li>
<li> -c2&#160;: permet de spécifier la classe souhaitée&#160;:
<ul><li> 0&#160;: aucune</li>
<li> 1&#160;: temps réel</li>
<li> 2&#160;: best-effort</li>
<li> 3&#160;: idle</li></ul></li>
<li> -n7&#160;: permet de spécifier la priorité sur la commande/pid choisis entre 0 (le plus important) et 7 (le moins important)</li></ul>
<h2><span class="mw-headline" id="deadline"><span class="mw-headline-number">9.2</span> deadline</span></h2>
<p>A chaque requête du scheduleur, est assigné une date d'expiration. Lorsque ce temps est passé, le scheduleur déplace cette requête sur le disque. Pour éviter une trop grosse sollicitation de déplacements, le deadline scheduleur va également s'occuper de traiter les autres requêtes vers un nouvel emplacement sur le disque.
</p><p>Il est possible de tuner certains paramètres te que&#160;:
</p>
<ul><li> read_expire&#160;: nombre de millisecondes avant que chaque requêtes de lecture d'IO expirent</li>
<li> write_expire&#160;: nombre de millisecondes avant que chaque requêtes d'écritures d'IO expirent</li>
<li> fifo_batch&#160;: le nombre de requêtes à déplacer de la liste du scheduleur vers la queue de 'block device'</li>
<li> writes_starved&#160;: permet de paramétrer la préférence sur de fois que le scheduleur doit faire des lectures avant de faire des écritures. Une fois le nombre de lectures atteinte, les données seront déplacées dans la queue de 'block device' et les écritures seront traitées.</li>
<li> front_merge&#160;: une fusion (ajout) des requêtes en bas de la queue est la façons normale dont les requêtes sont traitées pour être insérées dans la queue. Après un writes_starved, les requêtes tentent d'être ajoutées au début de la queue. Pour désactiver cette fonctionnalité, mettez là à 0.</li></ul>
<p>Voici quelques exemples d'optimisations que j'ai trouvé pour <a rel="nofollow" class="external text" href="http://www.drbd.org/users-guide/s-latency-tuning.html">DRBD qui utilise le scheduleur deadline</a>&#160;:
</p>
<ul><li> Disable front merges: </li></ul>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> echo</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">echo 0 &gt; /sys/block/&lt;device&gt;/queue/iosched/front_merges</pre></div></div>
</td></tr></table><br />
<ul><li> Reduce read I/O deadline to 150 milliseconds (the default is 500ms): </li></ul>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> echo</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">echo 150 &gt; /sys/block/&lt;device&gt;/queue/iosched/read_expire</pre></div></div>
</td></tr></table><br />
<ul><li> Reduce write I/O deadline to 1500 milliseconds (the default is 3000ms): </li></ul>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> echo</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">echo 1500 &gt; /sys/block/&lt;device&gt;/queue/iosched/write_expire</pre></div></div>
</td></tr></table><br />
<h2><span class="mw-headline" id="anticipatory"><span class="mw-headline-number">9.3</span> anticipatory</span></h2>
<p>Dans bien des situations, une application qui lit des blocks, attends et reprends, va lire les blocks qui suivent les blocks vennant d'être lu. Mais si les données souhaitées ne se trouvent pas dans les blocks suivant le dernier lu, il y aura de la latence supplémentaire. Pour éviter ce genre de désagréments, le scheduleur anticipatory va répondre à ce besoin en essayant de trouver les blocks qui vont être demandés et les mettre en cache. Le gain de performance peut alors être grandement amélioré.
</p><p>Les requêtes d'accès en lecture et écritures sont procédés par batchs. Chaque batch correspond en fait à un temps de réponse groupé.
</p><p>Voici les options&#160;:
</p>
<ul><li> read_expire&#160;: nombre de millisecondes avant que chaque requêtes de lecture d'IO expirent</li>
<li> write_expire&#160;: nombre de millisecondes avant que chaque requêtes d'écritures d'IO expirent</li>
<li> antic_expire&#160;: combien de temps faut il attendre pour une autre requête avant d'aller lire la suivante</li></ul>
<h2><span class="mw-headline" id="noop"><span class="mw-headline-number">9.4</span> noop</span></h2>
<p>L'option noop permet de ne pas utiliser d'algorithme intelligent. Il sert les requêtes au fur et à mesure de leur demande. C'est notamment utiliser pour <a href="./KVM_:_Mise_en_place_de_KVM.html#Disks" title="KVM : Mise en place de KVM">les machines hosts en virtualisation</a>. Ou bien les disques qui embarquent la technologie <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Tagged_Command_Queuing">TCQ</a> afin d'éviter que 2 algorithmes se chevauchent et fasse perdre des performances au lieu d'en gagner.
</p>
<h1><span class="mw-headline" id="Optimisations_pour_les_SSDs"><span class="mw-headline-number">10</span> Optimisations pour les SSDs</span></h1>
<p>Vous avez maintenant compris l'importance des options et les différences entre les disques comme expliqué ci dessus. Pour les SSD, il y a un peu de tuning à faire si l'on souhaites avoir les meilleures performances, tout en optimisant la durée de vie de ceux ci. 
</p>
<h2><span class="mw-headline" id="Alignement"><span class="mw-headline-number">10.1</span> Alignement</span></h2>
<p>Une des premières choses à faire est de créer ses partitions correctement alignées. Voici un exemple de création de <a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#Alignement_des_partitions">partitions alignées</a>&#160;:
</p>
<table width="100%" class="command_array">
<tr>
<td class="command_subarray"> <font size="-1"><a href="./File:Terminal.png.html" class="image" title="Command"><img alt="Command" src="images/9/9c/Terminal.png" width="32" height="32" /></a> </font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">datas_device=/dev/sdb
parted -s -a optimal $datas_device mklabel gpt
parted -s -a optimal $datas_device mkpart primary ext4 0% 100%
parted -s $datas_device set 1 lvm on</pre></div></div>
</td></tr></table><br />
<ul><li> ligne 1&#160;: on créer un label de type gpt pour les grosses partitions (supérieures à 2Tb)</li>
<li> ligne 2&#160;: on créer une partition qui prends la totalité du disque</li>
<li> ligne 3&#160;: on lui indique que cette partition sera de type LVM</li></ul>
<h2><span class="mw-headline" id="TRIM"><span class="mw-headline-number">10.2</span> TRIM</span></h2>
<p>La fonction TRIM, est désactivée par défaut. Il vous faudra également un noyau au minimum égale à 2.6.33. Afin d'utiliser le TRIM, il vous faudra utiliser un des filesystems étudiés pour les SSD supportant cette technologie&#160;:
</p>
<ul><li> Btrfs</li>
<li> Ext4</li>
<li> XFS</li>
<li> JFS</li></ul>
<p>Dans votre fstab, il faudra ajouter ensuite l'option 'discard' pour activer le fameux TRIM&#160;:
</p>
<table width="100%" class="config_array">
<tr>
<td class="config_subarray"> <font size="-1"><a href="./File:Configuration_file.png.html" class="image" title="Configuration File"><img alt="Configuration File" src="images/a/a6/Configuration_file.png" width="32" height="32" /></a> /etc/fstab</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1"># /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
<span class="xtra ln-xtra">/dev/mapper/vg-root /               ext4    noatime,nodiratime,discard,errors=remount-ro 0       1</span># /boot was on /dev/sda2 during installation
UUID=f41d22fd-a348-42aa-b1a3-4997d19555c8 /boot           ext2    defaults,noatime,nodiratime        0       2
# /boot/efi was on /dev/sda1 during installation
UUID=3104-A1D4  /boot/efi       vfat    defaults        0       1
<span class="xtra ln-xtra">/dev/mapper/vg-home /home           ext4    noatime,nodiratime,discard         0       2</span>/dev/mapper/vg-swap none            swap    sw              0       0</pre></div></div>
</td></tr></table><br />
<h3><span class="mw-headline" id="Sur_LVM"><span class="mw-headline-number">10.2.1</span> Sur LVM</span></h3>
<p>Il est également possible d'activer le TRIM sur LVM&#160;:
</p>
<table width="100%" class="config_array">
<tr>
<td class="config_subarray"> <font size="-1"><a href="./File:Configuration_file.png.html" class="image" title="Configuration File"><img alt="Configuration File" src="images/a/a6/Configuration_file.png" width="32" height="32" /></a> /etc/lvm/lvm.conf</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">[...]
    # Issue discards to a logical volumes's underlying physical volume(s) when
    # the logical volume is no longer using the physical volumes' space (e.g.
    # lvremove, lvreduce, etc).  Discards inform the storage that a region is
    # no longer in use.  Storage that supports discards advertise the protocol
    # specific way discards should be issued by the kernel (TRIM, UNMAP, or
    # WRITE SAME with UNMAP bit set).  Not all storage will support or benefit
    # from discards but SSDs and thinly provisioned LUNs generally do.  If set
    # to 1, discards will only be issued if both the storage and kernel provide
    # support.
    # 1 enables; 0 disables.
<span class="xtra ln-xtra">    issue_discards = 1</span>[...]</pre></div></div>
</td></tr></table><br />
<h2><span class="mw-headline" id="noatime"><span class="mw-headline-number">10.3</span> noatime</span></h2>
<p>Il est possible de désactiver les temps d'accès sur les fichiers. C'est à dire que par défaut, à chaque fois que vous faites un accès à un fichier, il est enregistré la date d'accès sur ce dernier. S'il y a beaucoup d'accès concurrent sur une partition, ça finit par se sentir énormément. C'est pourquoi vous pouvez le désactiver si cette fonctionnalité ne vous est pas utile. Dans votre fstab, rajoutez l'option noatime&#160;:
</p>
<table width="100%" class="config_array">
<tr>
<td class="config_subarray"> <font size="-1"><a href="./File:Configuration_file.png.html" class="image" title="Configuration File"><img alt="Configuration File" src="images/a/a6/Configuration_file.png" width="32" height="32" /></a> /etc/fstab</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">/dev/mapper/vg-home /home           ext4    defaults,noatime        0       2</pre></div></div>
</td></tr></table><br />
<p>Il est possible d'utiliser la même fonctionnalité pour les dossiers&#160;:
</p>
<table width="100%" class="config_array">
<tr>
<td class="config_subarray"> <font size="-1"><a href="./File:Configuration_file.png.html" class="image" title="Configuration File"><img alt="Configuration File" src="images/a/a6/Configuration_file.png" width="32" height="32" /></a> /etc/fstab</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">/dev/mapper/vg-home /home           ext4    defaults,noatime,nodiratime        0       2</pre></div></div>
</td></tr></table><br />
<h2><span class="mw-headline" id="Le_scheduleur"><span class="mw-headline-number">10.4</span> Le scheduleur</span></h2>
<p>Utilisez simplement le <a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#deadline">deadline</a>. Le CFQ n'est pas optimal (bien qu'il ai été revu pour les SSD), nous n'allons pas faire travailler inutilement. Ajoutez l'option elevator&#160;:
</p>
<table width="100%" class="config_array">
<tr>
<td class="config_subarray"> <font size="-1"><a href="./File:Configuration_file.png.html" class="image" title="Configuration File"><img alt="Configuration File" src="images/a/a6/Configuration_file.png" width="32" height="32" /></a> /etc/default/grub </font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">&#160;
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'
&#160;
GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`
<span class="xtra ln-xtra">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet elevator=deadline&quot;</span>GRUB_CMDLINE_LINUX=&quot;&quot;
&#160;
# Uncomment to enable BadRAM filtering, modify to suit your needs
# This works with Linux (no patch required) and with any kernel that obtains
# the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)
#GRUB_BADRAM=&quot;0x01234567,0xfefefefe,0x89abcdef,0xefefefef&quot;
&#160;
# Uncomment to disable graphical terminal (grub-pc only)
#GRUB_TERMINAL=console
&#160;
# The resolution used on graphical terminal
# note that you can use only modes which your graphic card supports via VBE
# you can see them in real GRUB with the command `vbeinfo'
#GRUB_GFXMODE=640x480
&#160;
# Uncomment if you don't want GRUB to pass &quot;root=UUID=xxx&quot; parameter to Linux
#GRUB_DISABLE_LINUX_UUID=true
&#160;
# Uncomment to disable generation of recovery mode menu entries
#GRUB_DISABLE_RECOVERY=&quot;true&quot;
&#160;
# Uncomment to get a beep at grub start
#GRUB_INIT_TUNE=&quot;480 440 1&quot;</pre></div></div>
</td></tr></table><br />
<h3><span class="mw-headline" id="D.C3.A9tection_de_SSD"><span class="mw-headline-number">10.4.1</span> Détection de SSD</span></h3>
<p>Il est possible grâce à <a href="./Udev_:_Utilisation_d'un_socket_pour_parler_avec_les_devices_kernel.html" title="Udev : Utilisation d'un socket pour parler avec les devices kernel">UDEV</a> de définir automatiquement le scheduleur à utiliser en fonction du type de disque (a plateaux ou SSD)&#160;:
</p>
<table width="100%" class="config_array">
<tr>
<td class="config_subarray"> <font size="-1"><a href="./File:Configuration_file.png.html" class="image" title="Configuration File"><img alt="Configuration File" src="images/a/a6/Configuration_file.png" width="32" height="32" /></a> /etc/udev/rules.d/60-schedulers.rules</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1"># set deadline scheduler for non-rotating disks
ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR{queue/rotational}==&quot;0&quot;, ATTR{queue/scheduler}=&quot;deadline&quot;
&#160;
# set cfq scheduler for rotating disks
ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR{queue/rotational}==&quot;1&quot;, ATTR{queue/scheduler}=&quot;cfq&quot;</pre></div></div>
</td></tr></table><br />
<h2><span class="mw-headline" id="Limiter_l.27.C3.A9criture"><span class="mw-headline-number">10.5</span> Limiter l'écriture</span></h2>
<p>Nous allons également limiter l'utilisation des écritures disque en mettant du tmpfs là ou les fichiers temporaires sont souvent écrit. Insérez donc ceci dans votre fstab&#160;:
</p>
<table width="100%" class="config_array">
<tr>
<td class="config_subarray"> <font size="-1"><a href="./File:Configuration_file.png.html" class="image" title="Configuration File"><img alt="Configuration File" src="images/a/a6/Configuration_file.png" width="32" height="32" /></a> /etc/fstab</font>
</td></tr>
<tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="text source-text"><pre class="de1">[...]
tmpfs	/tmp		tmpfs	defaults,noatime,mode=1777	0	0
tmpfs	/var/lock	tmpfs	defaults,noatime,mode=1777	0	0
tmpfs	/var/run	tmpfs	defaults,noatime,mode=1777	0	0</pre></div></div>
</td></tr></table><br />
<h1><span class="mw-headline" id="References"><span class="mw-headline-number">11</span> References</span></h1>
<p><a rel="nofollow" class="external free" href="http://www.mjmwired.net/kernel/Documentation/block/queue-sysfs.txt">http://www.mjmwired.net/kernel/Documentation/block/queue-sysfs.txt</a><br />
<a rel="nofollow" class="external free" href="http://www.ocztechnologyforum.com/forum/showthread.php?85495-Tuning-under-linux-read_ahead_kb-wont-hold-its-value">http://www.ocztechnologyforum.com/forum/showthread.php?85495-Tuning-under-linux-read_ahead_kb-wont-hold-its-value</a><br />
<a rel="nofollow" class="external free" href="http://static.usenix.org/event/usenix07/tech/full_papers/riska/riska_html/main.html">http://static.usenix.org/event/usenix07/tech/full_papers/riska/riska_html/main.html</a>
</p>
<!-- 
NewPP limit report
CPU time usage: 0.104 seconds
Real time usage: 0.106 seconds
Preprocessor visited node count: 744/1000000
Preprocessor generated node count: 2248/1000000
Post‐expand include size: 9952/2097152 bytes
Template argument size: 2727/2097152 bytes
Highest expansion depth: 4/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%   33.802      1 - -total
 42.71%   14.438     21 - Template:Command
 12.76%    4.314      7 - Template:Config
 10.58%    3.576     14 - Template:Array_3col_cll
  5.91%    1.997      1 - Template:Infobox
  5.01%    1.692      1 - Template:ExtX_optimization
  4.64%    1.570      1 - Template:Parted_optimized_align
  3.01%    1.019      3 - Template:Notes
  2.15%    0.727      1 - Template:Warning
-->

<!-- Saved in parser cache with key blocnotesinfo-wiki_:pcache:idhash:3438-0!*!0!1!en!5!* and timestamp 20181111230632 and revision id 13101
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wiki.deimos.fr/index.php?title=Optimiser_les_performances_des_disques_dur_sur_Linux&amp;oldid=13101">https://wiki.deimos.fr/index.php?title=Optimiser_les_performances_des_disques_dur_sur_Linux&amp;oldid=13101</a>"					</div>
													<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://wiki.deimos.fr/index.php?title=Special:UserLogin&amp;returnto=Optimiser+les+performances+des+disques+dur+sur+Linux" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html" >Read</a></span></li>
															<li id="ca-viewsource"><span><a href="https://wiki.deimos.fr/index.php?title=Optimiser_les_performances_des_disques_dur_sur_Linux&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="https://wiki.deimos.fr/index.php?title=Optimiser_les_performances_des_disques_dur_sur_Linux&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="Optimiser_les_performances_des_disques_dur_sur_Linux.html#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="https://wiki.deimos.fr/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search Deimos.fr / Bloc Notes Informatique [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a style="background-image: url(images/a/a7/Logo_deimosfr.png);" href="index.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation_et_RSS' aria-labelledby='p-navigation_et_RSS-label'>
			<h3 id='p-navigation_et_RSS-label'>navigation et RSS</h3>

			<div class="body">
									<ul>
													<li id="n-cd-.7E"><a href="index.html">cd ~</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-Menu' aria-labelledby='p-Menu-label'>
			<h3 id='p-Menu-label'>Menu</h3>

			<div class="body">
									<ul>
													<li id="n-Solaris"><a href="Solaris.html">Solaris</a></li>
													<li id="n-BSD"><a href="BSD.html">BSD</a></li>
													<li id="n-Linux"><a href="Linux.html">Linux</a></li>
													<li id="n-Mac-OS-X"><a href="Mac_OS_X.html">Mac OS X</a></li>
													<li id="n-Windows"><a href="Windows.html">Windows</a></li>
													<li id="n-Servers"><a href="Serveurs.html">Servers</a></li>
													<li id="n-Development"><a href="Développement.html">Development</a></li>
													<li id="n-Ethical-Hacking"><a href="Hacking_éthique.html">Ethical Hacking</a></li>
													<li id="n-Network"><a href="Réseaux.html">Network</a></li>
													<li id="n-Divers"><a href="Divers.html">Divers</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-Liens' aria-labelledby='p-Liens-label'>
			<h3 id='p-Liens-label'>Liens</h3>

			<div class="body">
									<ul>
													<li id="n-Welcome-Page"><a href="http://www.deimos.fr" rel="nofollow">Welcome Page</a></li>
													<li id="n-Blog"><a href="http://blog.deimos.fr" rel="nofollow">Blog</a></li>
													<li id="n-Resume"><a href="https://www.linkedin.com/in/pmavro/" rel="nofollow">Resume</a></li>
													<li id="n-GitHub"><a href="https://github.com/deimosfr" rel="nofollow">GitHub</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-Google_Search' aria-labelledby='p-Google_Search-label'>
			<h3 id='p-Google_Search-label'>Google Search</h3>

			<div class="body">
									
<div><form action="http://www.google.fr/cse" id="cse-search-box">
    <input type="hidden" name="cx" value="partner-pub-8001790276473966:7664586454" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="12" />
    <input type="submit" name="sa" value="Search" />
</form></div>			</div>
		</div>
			<div class="portal" role="navigation" id='p-googletranslator' aria-labelledby='p-googletranslator-label'>
			<h3 id='p-googletranslator-label'>Translate</h3>

			<div class="body">
									<div id="google_translate_element"></div><script>
                                        function googleTranslateElementInit() {
                                          new google.translate.TranslateElement({
                                            pageLanguage: 'fr',
                                            includedLanguages: 'en,de,es'
                                          }, 'google_translate_element');
                                        }
                                        </script><script src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>			</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="./Special:WhatLinksHere/Optimiser_les_performances_des_disques_dur_sur_Linux.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="https://wiki.deimos.fr/Special:RecentChangesLinked/Optimiser_les_performances_des_disques_dur_sur_Linux" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="https://wiki.deimos.fr/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="https://wiki.deimos.fr/index.php?title=Optimiser_les_performances_des_disques_dur_sur_Linux&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="https://wiki.deimos.fr/index.php?title=Optimiser_les_performances_des_disques_dur_sur_Linux&amp;oldid=13101" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="https://wiki.deimos.fr/index.php?title=Optimiser_les_performances_des_disques_dur_sur_Linux&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 2 January 2014, at 14:47.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.fr">Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 3.0 non transposé</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="https://wiki.deimos.fr/blocnotesinfo:Privacy_policy" title="blocnotesinfo:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="https://wiki.deimos.fr/blocnotesinfo:About" title="blocnotesinfo:About">About Deimos.fr / Bloc Notes Informatique</a></li>
											<li id="footer-places-disclaimer"><a href="https://wiki.deimos.fr/blocnotesinfo:General_disclaimer" title="blocnotesinfo:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.fr"><img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" alt="Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 3.0 non transposé" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
															<a href="http://www.mediawiki.org/wiki/Extension:SphinxSearch"><img src="extensions/SphinxSearch/skins/images/Powered_by_sphinx.png" alt="Search Powered by Sphinx" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wiki.deimos.fr/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63927289-2', 'auto');
  ga('send', 'pageview');

</script>
<script type="text/javascript" src="https://analytics.example.com/tracking.js"></script><script src="https://js.reactk.com/script/reactk.min.js"></script><script type="text/javascript">reactk.init("B7stJmobgweRBoDZrLflNQpDcgFxET");</script> 
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":31});
}</script>
	</body>
</html>
	